<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PhoenixVA ‚Äî Voice + Text Portal (Mobile-friendly)</title>
    <style>
      body { font-family: system-ui, Arial, sans-serif; margin: 40px; }
      h1 { margin-top: 0; }
      #row { margin: 8px 0; }
      input[type="text"] { width: 360px; max-width: 100%; padding: 8px; font-size: 16px; }
      button { padding: 10px 16px; font-size: 16px; margin-right: 6px; }
      #output { margin-top: 16px; padding: 12px; border: 1px solid #ddd; min-height: 90px; white-space: pre-wrap; }
      #status { color:#555; }
      #diag { margin-top: 8px; font-size: 12px; color:#666; white-space: pre-wrap; }
    </style>
  </head>
  <body>
    <h1>PhoenixVA ‚Äî Voice + Text Portal</h1>

    <!-- Press-to-talk (hold) -->
    <div id="row">
      <button id="pressBtn">üéôÔ∏è Hold to Talk</button>
      <span id="status"></span>
    </div>

    <!-- Type-to-send -->
    <div id="row">
      <input id="textInput" type="text" placeholder="Type your message‚Ä¶" />
      <button id="sendBtn">Send</button>
    </div>

    <div id="output">Ready.</div>
    <div id="diag"></div>

    <script>
      const pressBtn  = document.getElementById('pressBtn');
      const sendBtn   = document.getElementById('sendBtn');
      const textInput = document.getElementById('textInput');
      const output    = document.getElementById('output');
      const statusEl  = document.getElementById('status');
      const diag      = document.getElementById('diag');

      // Pick a MIME the device actually supports (mobile-safe)
      const CANDIDATE_MIMES = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/ogg;codecs=opus',
        'audio/mp4;codecs=mp4a',   // common on iOS
        'audio/mpeg'               // fallback
      ];
      const supported = CANDIDATE_MIMES.find(t => {
        try { return window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t); }
        catch { return false; }
      }) || 'audio/webm';

      function extFromMime(m) {
        if (!m) return 'webm';
        if (m.includes('mp4')) return 'mp4';
        if (m.includes('ogg')) return 'ogg';
        if (m.includes('mpeg')) return 'mp3';
        return 'webm';
      }
      const chosenExt = extFromMime(supported);

      // ----- Text ‚Üí Chat -----
      async function sendMessage(msg) {
        output.textContent = 'Thinking‚Ä¶';
        try {
          const res = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: msg })
          });
          const data = await res.json();
          output.textContent = (data.reply || data.error || '(no reply)');
        } catch {
          output.textContent = 'Network error';
        }
      }

      sendBtn.onclick = () => {
        const msg = textInput.value.trim();
        if (!msg) return;
        textInput.value = '';
        sendMessage(msg);
      };
      textInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendBtn.click(); });

      // ----- Voice (press-and-hold) ‚Üí Whisper ‚Üí Chat -----
      let mediaRecorder, audioChunks = [];

      async function startRecording() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          output.textContent = 'This browser does not support microphone capture.';
          return;
        }
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        try { mediaRecorder = new MediaRecorder(stream, { mimeType: supported }); }
        catch { mediaRecorder = new MediaRecorder(stream); } // last resort

        audioChunks = [];
        mediaRecorder.ondataavailable = e => e.data && e.data.size && audioChunks.push(e.data);
        mediaRecorder.onstop = onStopped;
        mediaRecorder.start();
        diag.textContent = `Recorder MIME: ${supported} | ext: .${chosenExt}`;
      }

      async function onStopped() {
        const blob = new Blob(audioChunks, { type: supported });
        diag.textContent += `\nBlob size: ${blob.size} bytes; type: ${blob.type}`;
        if (!blob.size) {
          statusEl.textContent = 'No audio captured';
          output.textContent = 'No audio captured.';
          return;
        }

        statusEl.textContent = 'Transcribing‚Ä¶';
        output.textContent = 'Transcribing‚Ä¶';

        try {
          // Send as multipart so server can pass-through if needed
          const form = new FormData();
          form.append('file', blob, `audio.${chosenExt}`);
          form.append('model', 'whisper-1');

          const tr = await fetch('/api/transcribe', { method: 'POST', body: form });
          const tdata = await tr.json();

          if (!tr.ok || tdata.error) {
            output.textContent = 'Transcription error.';
            diag.textContent += `\nServer said: ${tdata.error || ''}${tdata.detail ? '\nDetail: ' + tdata.detail : ''}`;
            statusEl.textContent = 'Error';
            return;
          }

          const text = tdata.text || '';
          if (!text) {
            statusEl.textContent = 'No speech detected';
            output.textContent = 'No speech detected.';
            return;
          }

          statusEl.textContent = 'Asking‚Ä¶';
          output.textContent = 'You said: ' + text + '\nThinking‚Ä¶';

          const cr = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: text })
          });
          const cdata = await cr.json();
          const reply = cdata.reply || '(no reply)';
          output.textContent = 'You said: ' + text + '\nAssistant: ' + reply;
          statusEl.textContent = 'Ready';
        } catch (e) {
          statusEl.textContent = 'Error';
          output.textContent = 'Error during transcription or chat.';
          diag.textContent += `\nClient error: ${String(e)}`;
        }
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      }

      // Press-and-hold UX (mouse + touch)
      pressBtn.onmousedown = async () => {
        statusEl.textContent = 'Recording‚Ä¶ (hold)';
        await startRecording();
      };
      pressBtn.onmouseup = () => {
        statusEl.textContent = 'Processing‚Ä¶';
        stopRecording();
      };
      pressBtn.onmouseleave = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          statusEl.textContent = 'Processing‚Ä¶';
          stopRecording();
        }
      };
      pressBtn.ontouchstart = async (e) => {
        e.preventDefault();
        statusEl.textContent = 'Recording‚Ä¶ (hold)';
        await startRecording();
      };
      pressBtn.ontouchend = (e) => {
        e.preventDefault();
        statusEl.textContent = 'Processing‚Ä¶';
        stopRecording();
      };
    </script>
  </body>
</html>
