<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PhoenixVA ‚Äî Voice + Text Portal (Mobile-friendly)</title>
    <style>
      body { font-family: system-ui, Arial, sans-serif; margin: 40px; }
      h1 { margin-top: 0; }
      #row { margin: 8px 0; display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
      input[type="text"] { width: 360px; max-width: 100%; padding: 8px; font-size: 16px; }
      button { padding: 10px 16px; font-size: 16px; margin-right: 6px; }
      #output { margin-top: 16px; padding: 12px; border: 1px solid #ddd; min-height: 90px; white-space: pre-wrap; }
      #status { color:#555; }
      #diag { margin-top: 8px; font-size: 12px; color:#666; white-space: pre-wrap; max-height: 180px; overflow:auto; }
      .rt-container{ display:flex; align-items:center; gap:12px; padding:8px 12px; border:2px solid black; border-radius:16px; background:black; }
      .rt-label{ font-weight:700; font-size:18px; color:#b3132c; letter-spacing:.3px; }
      .rt-toggle{ position:relative; width:76px; height:40px; border-radius:999px; background:#222; border:2px solid #b3132c; cursor:pointer; display:inline-flex; align-items:center; padding:2px; transition:background .2s ease; }
      .rt-toggle[aria-checked="true"]{ background:#330000; }
      .rt-thumb{ width:34px; height:34px; border-radius:999px; background:#b3132c; transform: translateX(0); transition: transform .2s ease; }
      .rt-toggle[aria-checked="true"] .rt-thumb{ transform: translateX(36px); }
      .rt-note{ font-size:12px; color:#b3132c; margin-left:4px; }
      .rt-badge{ font-size:12px; padding:4px 8px; border-radius:999px; background:black; color:#b3132c; border:1px solid #b3132c; }
      .rt-badge.off{ background:#111; color:#666; border-color:#333; }
    </style>
  </head>
  <body>
    <h1>PhoenixVA ‚Äî Voice + Text Portal</h1>

    <div id="row">
      <button id="pressBtn">üéôÔ∏è Hold to Talk</button>

      <div class="rt-container" role="group" aria-label="CHAT toggle">
        <span class="rt-label">CHAT</span>
        <div id="rtToggle" class="rt-toggle" role="switch" aria-checked="false" tabindex="0" aria-label="Toggle CHAT mode">
          <div class="rt-thumb"></div>
        </div>
        <span id="rtBadge" class="rt-badge off">OFF</span>
        <span class="rt-note">Realtime loop active when ON</span>
      </div>

      <span id="status"></span>
    </div>

    <div id="row">
      <input id="textInput" type="text" placeholder="Type your message‚Ä¶" />
      <button id="sendBtn">Send</button>
    </div>

    <div id="output">Ready.</div>
    <div id="diag"></div>

    <script>
      const pressBtn  = document.getElementById('pressBtn');
      const sendBtn   = document.getElementById('sendBtn');
      const textInput = document.getElementById('textInput');
      const output    = document.getElementById('output');
      const statusEl  = document.getElementById('status');
      const diag      = document.getElementById('diag');
      const rtToggle  = document.getElementById('rtToggle');
      const rtBadge   = document.getElementById('rtBadge');

      let realtimeActive = false;

      // --- MIME detect ---
      const CANDIDATE_MIMES = [
        'audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/mp4;codecs=mp4a','audio/mpeg'
      ];
      function detectMime(){
        try{
          if(!(window.MediaRecorder && MediaRecorder.isTypeSupported)) return null;
          return CANDIDATE_MIMES.find(t=>MediaRecorder.isTypeSupported(t)) || null;
        }catch{ return null; }
      }
      let chosenMime = detectMime() || 'audio/webm';
      function log(s){ diag.textContent += `\n${s}`; diag.scrollTop = diag.scrollHeight; }

      // --- helpers ---
      async function speak(text){
        try{
          const r = await fetch('/api/speak',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ text, voice:'alloy' }) });
          if(!r.ok) return;
          const buf = await r.arrayBuffer();
          const url = URL.createObjectURL(new Blob([buf],{type:'audio/mpeg'}));
          await new Promise(res=>{ const a=new Audio(url); a.onended=res; a.onerror=res; a.play().catch(res); });
        }catch(e){ log(`TTS error: ${String(e)}`); }
      }
      function blobToDataUrl(blob){
        return new Promise((resolve,reject)=>{ const fr=new FileReader(); fr.onload=()=>resolve(fr.result); fr.onerror=reject; fr.readAsDataURL(blob); });
      }

      // --- text path (also used by voice "search:") ---
      async function sendMessage(msg){
        output.textContent='Thinking‚Ä¶';
        const m = msg.trim();
        const isSearch = /^(\s*search:|\s*web:)/i.test(m);
        if(isSearch){
          const q = m.replace(/^(\s*search:|\s*web:)/i,'').trim();
          if(!q){ output.textContent='Please provide a search query.'; return; }
          try{
            const r = await fetch('/api/search',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ q }) });
            const data = await r.json();
            if(!r.ok || data.error){ output.textContent='Search error.'; log(`Search error: ${(data && (data.error||data.detail))||r.statusText}`); return; }
            const lines = (data.results||[]).map((it,i)=>`${i+1}. ${it.title}\n${it.link}\n${it.snippet}`).join('\n\n');
            output.textContent = lines || 'No results.';
            const top=(data.results||[])[0]; if(top){ await speak(`Top result: ${top.title}. ${top.snippet}`); }
            return;
          }catch(e){ output.textContent='Search request failed.'; log(`Search fetch error: ${String(e)}`); return; }
        }
        try{
          const r = await fetch('/api/chat',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ message: m }) });
          const data = await r.json();
          const reply = data.reply || data.error || '(no reply)';
          output.textContent = reply;
          await speak(reply);
        }catch{ output.textContent='Network error'; }
      }
      sendBtn.onclick=()=>{ const msg=textInput.value.trim(); if(!msg) return; textInput.value=''; sendMessage(msg); };
      textInput.addEventListener('keydown',e=>{ if(e.key==='Enter') sendBtn.click(); });

      // --- single-shot (unchanged) ---
      let mediaRecorder, audioChunks=[];
      async function startRecording(){
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ output.textContent='This browser does not support microphone capture.'; return; }
        const stream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:true, noiseSuppression:true, autoGainControl:true, channelCount:1 } });
        try{ mediaRecorder = new MediaRecorder(stream, { mimeType: chosenMime }); } catch{ mediaRecorder = new MediaRecorder(stream); }
        audioChunks=[]; mediaRecorder.ondataavailable=e=>e.data && e.data.size && audioChunks.push(e.data);
        mediaRecorder.onstop=onStoppedSingleShot; mediaRecorder.start(); log(`Recorder MIME (single-shot): ${chosenMime}`);
      }
      async function onStoppedSingleShot(){
        const blob = new Blob(audioChunks,{type:chosenMime});
        if(!blob.size){ statusEl.textContent='No audio captured'; output.textContent='No audio captured.'; return; }
        statusEl.textContent='Transcribing‚Ä¶'; output.textContent='Transcribing‚Ä¶';
        try{
          const dataUrl = await blobToDataUrl(blob);
          const tr = await fetch('/api/transcribe',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ audio:dataUrl }) });
          const tdata = await tr.json();
          if(!tr.ok || tdata.error){ output.textContent='Transcription error.'; log(`Transcribe error: ${tdata.error || tr.statusText}`); statusEl.textContent='Error'; return; }
          const text=(tdata.text||'').trim(); if(!text){ statusEl.textContent='No speech detected'; output.textContent='No speech detected.'; return; }
          if(/^(\s*search:|\s*web:)/i.test(text)){ statusEl.textContent='Searching‚Ä¶'; await sendMessage(text); statusEl.textContent='Ready'; return; }
          statusEl.textContent='Asking‚Ä¶'; output.textContent='You said: '+text+'\nThinking‚Ä¶';
          const cr=await fetch('/api/chat',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ message:text }) });
          const cdata=await cr.json(); const reply=cdata.reply||'(no reply)'; output.textContent='You said: '+text+'\nAssistant: '+reply; statusEl.textContent='Ready'; await speak(reply);
        }catch(e){ statusEl.textContent='Error'; output.textContent='Error during transcription or chat.'; log(`Client error: ${String(e)}`); }
      }
      function stopRecording(){ if(mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop(); }
      pressBtn.onmousedown=async()=>{ statusEl.textContent=realtimeActive?'Recording‚Ä¶ (press) ‚Äî CHAT ON':'Recording‚Ä¶ (hold)'; await startRecording(); };
      pressBtn.onmouseup=()=>{ statusEl.textContent='Processing‚Ä¶'; stopRecording(); };
      pressBtn.onmouseleave=()=>{ if(mediaRecorder && mediaRecorder.state==='recording'){ statusEl.textContent='Processing‚Ä¶'; stopRecording(); } };
      pressBtn.ontouchstart=async(e)=>{ e.preventDefault(); statusEl.textContent=realtimeActive?'Recording‚Ä¶ (press) ‚Äî CHAT ON':'Recording‚Ä¶ (hold)'; await startRecording(); };
      pressBtn.ontouchend=(e)=>{ e.preventDefault(); statusEl.textContent='Processing‚Ä¶'; stopRecording(); };

      // --- realtime with batching + rate-limit + backoff ---
      let rtStream=null, rtRecorder=null, rtInterval=null, rtTick=0;
      let rtBufferText='', inactivityTimer=null;

      // batching/rate limiting state
      let batchBlobs=[];                 // accumulate blobs here
      let lastSendTs=0;
      let sending=false;                 // a send in flight
      let backoffUntil=0;                // timestamp until which we pause sending
      const CHUNK_MS=400;                // requestData cadence
      const SEND_INTERVAL_MS=1000;       // min ms between sends
      const MAX_BATCH_MS=1600;           // force flush after this much time
      const MAX_BATCH_BYTES=200*1024;    // force flush after ~200KB
      const INACTIVITY_MS=1300;          // finalize after quiet period
      const END_PUNCT_RE=/[.!?‚Ä¶]"?$/;

      function micConstraints(){ return { echoCancellation:true, noiseSuppression:true, autoGainControl:true, channelCount:1 }; }
      function mergePartial(prev, incoming){
        if(!incoming) return prev;
        if(incoming.startsWith(prev)) return incoming;
        if(prev && incoming && prev.endsWith(incoming)) return prev;
        return prev ? (prev+' '+incoming) : incoming;
      }
      function scheduleFinalize(){
        if(inactivityTimer) clearTimeout(inactivityTimer);
        inactivityTimer=setTimeout(()=>finalizeUtterance(), INACTIVITY_MS);
      }

      async function startRealtime(){
        if(rtRecorder) return;
        statusEl.textContent='CHAT mode: listening‚Ä¶';
        rtBufferText=''; rtTick=0; batchBlobs=[]; lastSendTs=0; sending=false; backoffUntil=0;

        try{
          rtStream=await navigator.mediaDevices.getUserMedia({ audio: micConstraints() });
          try{ rtRecorder=new MediaRecorder(rtStream,{mimeType:chosenMime}); }catch{ rtRecorder=new MediaRecorder(rtStream); }
          rtRecorder.ondataavailable=onRtChunk;
          rtRecorder.start();
          rtInterval=setInterval(()=>{
            rtTick++;
            try{ if(rtRecorder && rtRecorder.state==='recording') rtRecorder.requestData(); }catch(e){ log(`[CHAT] requestData error: ${String(e)}`); }
            if(rtTick%5===0) log(`[CHAT] tick ${rtTick}`);
            maybeSendBatch();
          }, CHUNK_MS);
          log(`[CHAT] Realtime started (${chosenMime}); forced chunks every ${CHUNK_MS}ms`);
        }catch(err){
          log(`[CHAT] Failed to start: ${String(err)}`);
          statusEl.textContent='CHAT error: mic unavailable';
          stopRealtime();
        }
      }

      async function stopRealtime(){
        try{ if(rtInterval) clearInterval(rtInterval); }catch{}
        rtInterval=null;
        try{ if(rtRecorder && rtRecorder.state!=='inactive') rtRecorder.stop(); }catch{}
        rtRecorder=null;
        try{ if(rtStream) rtStream.getTracks().forEach(t=>t.stop()); }catch{}
        rtStream=null;
        if(inactivityTimer){ clearTimeout(inactivityTimer); inactivityTimer=null; }
        statusEl.textContent='CHAT OFF. Press-and-hold active.';
      }

      function onRtChunk(ev){
        if(!ev || !ev.data) return;
        const size=ev.data.size||0;
        log(`[CHAT] chunk: ${size} bytes`);
        if(size>0) batchBlobs.push(ev.data); // accumulate
      }

      function batchAgeMs(){ return Date.now() - (lastSendTs || (Date.now()-MAX_BATCH_MS-1)); }
      function batchSizeBytes(){
        let n=0; for(const b of batchBlobs) n+=b.size||0; return n;
      }

      function maybeSendBatch(){
        const now=Date.now();
        if (now < backoffUntil) return;              // backing off after failures
        if (sending) return;                          // one in flight
        if (!batchBlobs.length) return;              // nothing to send
        const age=batchAgeMs();
        const size=batchSizeBytes();
        // Rate limit: send only if interval elapsed, or batch is "big" / old
        if ( (now - lastSendTs) < SEND_INTERVAL_MS && age < MAX_BATCH_MS && size < MAX_BATCH_BYTES) return;

        // Build a single blob and send
        const blob=new Blob(batchBlobs,{type:chosenMime});
        batchBlobs=[];                                // clear for next accumulation
        sendBatch(blob).catch(()=>{});                // fire and forget (we manage state inside)
      }

      async function sendBatch(blob){
        sending=true;
        try{
          const dataUrl=await blobToDataUrl(blob);
          const tr=await fetch('/api/transcribe',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ audio:dataUrl }) });
          const tdata=await tr.json();
          if(!tr.ok || tdata.error){
            log(`[CHAT] transcribe server error: ${tdata.error || tr.statusText}`);
            // back off a bit on server errors
            backoffUntil=Date.now()+1200;
            return;
          }

          const text=(tdata.text||'').trim();
          if(text){
            rtBufferText=mergePartial(rtBufferText,text);
            output.textContent=`You (live): ${rtBufferText}`;
            if(END_PUNCT_RE.test(rtBufferText.trim())){
              if(inactivityTimer){ clearTimeout(inactivityTimer); inactivityTimer=null; }
              await finalizeUtterance();
            } else {
              scheduleFinalize();
            }
          }
          lastSendTs=Date.now();
        }catch(e){
          log(`[CHAT] transcribe network error: ${String(e)}`);
          // network failure ‚Üí short backoff and let batching continue
          backoffUntil=Date.now()+1500;
        }finally{
          sending=false;
        }
      }

      async function finalizeUtterance(){
        if(inactivityTimer){ clearTimeout(inactivityTimer); inactivityTimer=null; }
        const utterance=rtBufferText.trim();
        rtBufferText='';
        if(!utterance) return;

        await pauseRealtimeDuring(async ()=>{
          statusEl.textContent='Thinking‚Ä¶';
          output.textContent=`You: ${utterance}\nThinking‚Ä¶`;

          if(/^(\s*search:|\s*web:)/i.test(utterance)){
            await sendMessage(utterance);
            statusEl.textContent='CHAT mode: listening‚Ä¶';
            return;
          }

          try{
            const cr=await fetch('/api/chat',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ message: utterance }) });
            const cdata=await cr.json();
            const reply=cdata.reply||'(no reply)';
            output.textContent=`You: ${utterance}\nAssistant: ${reply}`;
            await speak(reply);
          }catch(err){
            log(`[CHAT] chat error: ${String(err)}`);
            output.textContent=`You: ${utterance}\nAssistant: (error)`;
          }finally{
            statusEl.textContent='CHAT mode: listening‚Ä¶';
          }
        });
      }

      async function pauseRealtimeDuring(fn){
        const wasActive=!!rtRecorder;
        if(wasActive){ try{ rtRecorder.stop(); }catch{} rtRecorder=null; }
        try{ await fn(); }
        finally{ if(realtimeActive){ await startRealtime(); } }
      }

      // --- toggle wiring ---
      function setRealtimeActive(on){
        realtimeActive=!!on;
        rtToggle.setAttribute('aria-checked', realtimeActive ? 'true':'false');
        rtBadge.textContent=realtimeActive ? 'ON' : 'OFF';
        rtBadge.classList.toggle('off', !realtimeActive);
        if(realtimeActive){ statusEl.textContent='CHAT mode: initializing‚Ä¶'; startRealtime(); }
        else { stopRealtime(); }
      }
      function toggleRealtime(){
        const next=!(rtToggle.getAttribute('aria-checked')==='true');
        setRealtimeActive(next);
      }
      rtToggle.addEventListener('click', toggleRealtime);
      rtToggle.addEventListener('keydown', e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); toggleRealtime(); } });

      document.addEventListener('visibilitychange', ()=>{
        if(document.visibilityState==='visible' && realtimeActive && !rtRecorder){
          log('[CHAT] page visible ‚Äî restarting realtime');
          startRealtime();
        }
      });

      // init
      setRealtimeActive(false);
    </script>
  </body>
</html>
