<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phoenix VA — Realtime</title>
  <meta name="color-scheme" content="light dark" />
  <style>
    :root {
      --navy: #0B1B34;
      --card: #0F223F;
      --text: #E8EEF9;
      --muted: #9FB1D1;
      --accent: #FFFFFF;
      --btn-bg: #001F3F;
      --btn-tx: #FFFFFF;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      background: var(--navy);
      color: var(--text);
      display: grid;
      place-items: center;
      min-height: 100svh;
    }
    .wrap { width: 100%; max-width: 720px; padding: 20px; display: grid; gap: 16px; }
    .brand { display: grid; place-items: center; gap: 10px; text-align: center; }
    .brand img {
      width: 96px; height: auto; display: block;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,.25));
      user-select: none;
    }
    .brand h1 { margin: 0; font-size: 18px; font-weight: 600; color: var(--muted); letter-spacing: .3px; }
    .card {
      background: color-mix(in oklab, var(--card) 90%, black 10%);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, .btn {
      appearance: none; border: none; background: #F4F6FC; color: #0B1B34;
      padding: 10px 14px; border-radius: 12px; font-weight: 700; cursor: pointer;
      transition: transform .04s ease, opacity .2s ease, background .2s ease;
    }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #voiceToggle {
      background: var(--btn-bg); color: var(--btn-tx);
      display: inline-flex; align-items: center; gap: 10px;
      padding: 12px 18px; border-radius: 16px;
    }
    #voiceToggle img { width: 28px; height: 28px; object-fit: contain; display: block; pointer-events: none; user-select: none; }
    #voiceToggle:hover { background: #003366; }
    .btn-outline { background: transparent; color: var(--accent); border: 1px solid rgba(255,255,255,.2); }
    input[type="text"] {
      flex: 1 1 220px; background: rgba(255,255,255,.06); color: var(--text);
      border: 1px solid rgba(255,255,255,.15); border-radius: 10px; padding: 10px 12px; outline: none;
    }
    input::placeholder { color: rgba(255,255,255,.5); }
    #log {
      white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px; line-height: 1.4; color: #CFE2FF; max-height: 280px; overflow: auto;
      background: rgba(0,0,0,.25); border-radius: 10px; padding: 12px; border: 1px solid rgba(255,255,255,.08);
    }
    .hint { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="brand">
      <img src="/public/logo.png" alt="Phoenix VA Logo" />
      <h1>Phoenix VA — Realtime</h1>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <button id="voiceToggle">
            <img src="/public/logo.png" alt="Phoenix VA Logo" width="56" height="56" />
            <span id="voiceLabel">Start</span>
          </button>

          <button id="googleConnect" class="btn-outline" title="Connect Google">Connect Google</button>
        </div>
        <span class="hint" id="status">idle</span>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="textInput" type="text" placeholder="Ask me anything">
        <button id="sendText">Send</button>
      </div>

      <audio id="assistantAudio" autoplay playsinline style="display:none"></audio>
      <div id="log" style="margin-top:12px"></div>
    </div>
  </div>

  <script type="module">
    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const btn = document.getElementById('voiceToggle');
    const btnLabel = document.getElementById('voiceLabel');
    const btnGoogle = document.getElementById('googleConnect');
    const inputEl = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendText');
    const setSendReady = (ready) => { sendBtn.disabled = !ready; };
    setSendReady(false);

    const audioEl = document.getElementById('assistantAudio');

    const log = (...a) => {
      const s = a.map(x => typeof x === 'string' ? x : JSON.stringify(x, null, 2)).join(' ');
      logEl.textContent += s + '\n';
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...a);
    };
    const setStatus = (s) => { statusEl.textContent = s; };

    let pc = null, mic = null, dc = null, live = false;

    // Response state management
    window.__responseActive = false;
    window.__waitingForResponseId = false;
    window.__lastResponseCreatedId = null;
    window.__pendingToolResults = [];

    const RESPONSE_ACTIVE_FALLBACK_MS = 12000;
    let __responseActiveFallbackTimer = null;
    function setResponseActive(active) {
      window.__responseActive = !!active;
      if (active) {
        clearTimeout(__responseActiveFallbackTimer);
        __responseActiveFallbackTimer = setTimeout(() => {
          if (window.__responseActive) {
            log('[WARN] responseActive fallback fired; clearing flag');
            window.__responseActive = false;
            window.__waitingForResponseId = false;
            window.__lastResponseCreatedId = null;
            flushPendingToolResults();
          }
        }, RESPONSE_ACTIVE_FALLBACK_MS);
      } else {
        clearTimeout(__responseActiveFallbackTimer);
        __responseActiveFallbackTimer = null;
      }
    }

    async function sendResponseInstructions(text) {
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DC not open; cannot send response.create');
        return;
      }
      if (window.__responseActive) {
        window.__pendingToolResults.push({ text });
        log('[INFO] response active — queued tool result');
        return;
      }
      try {
        window.__waitingForResponseId = true;
        setResponseActive(true);
        dc.send(JSON.stringify({
          type: 'response.create',
          response: { instructions: text }
        }));
        log('[DC=>] response.create (tool output sent)');
      } catch (e) {
        log('[ERR] sendResponseInstructions send failed:', e?.message || e);
        setResponseActive(false);
        window.__waitingForResponseId = false;
      }
    }

    function flushPendingToolResults() {
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DC not open; cannot flush pending tool results');
        return;
      }
      if (window.__responseActive) {
        log('[INFO] still response active; will flush later');
        return;
      }
      const item = window.__pendingToolResults.shift();
      if (item) {
        log('[INFO] flushing queued tool result');
        sendResponseInstructions(item.text);
      }
    }

    btnGoogle.addEventListener('click', () => {
      window.location.href = '/api/google.js?op=start';
    });

    sendBtn.addEventListener('click', () => {
      const text = (inputEl.value || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DataChannel not open yet; cannot send text.');
        return;
      }
      try {
        dc.send(JSON.stringify({ type: 'response.create', response: { instructions: text }}));
        log('[TX] text prompt → response.create');
      } catch (e) {
        log('[ERR] send text:', e?.message || e);
      }
    });

    // Optional helper (unused by Drive add-on, but handy if you want to speak lists of urgent items from Sheets)
    function buildUrgentTextFromValues(values) {
      if (!Array.isArray(values) || !values.length) return 'No data returned from sheet.';
      const header = values[0].map(h => (h||'').toString().trim().toLowerCase());
      const hasHeader = header.some(h => h.includes('task') || h.includes('urgency') || h.includes('status') || h.includes('task/job'));
      let taskIdx = 0, descIdx = 1, urgencyIdx = 2, statusIdx = 3;
      if (hasHeader) {
        header.forEach((h, i) => {
          if (h.includes('task') && taskIdx === 0) taskIdx = i;
          if ((h.includes('desc') || h.includes('description')) && descIdx === 1) descIdx = i;
          if ((h.includes('urg') || h.includes('priority')) && urgencyIdx === 2) urgencyIdx = i;
          if (h.includes('status') && statusIdx === 3) statusIdx = i;
        });
      } else {
        taskIdx = 0; descIdx = 1; urgencyIdx = 2; statusIdx = 3;
      }
      const startRow = hasHeader ? 1 : 0;
      const urgentRows = [];
      for (let i = startRow; i < values.length; i++) {
        const row = values[i] || [];
        const urgency = (row[urgencyIdx] || '').toString().trim().toLowerCase();
        const status = (row[statusIdx] || '').toString().trim().toLowerCase();
        if ((urgency === 'high' || urgency === 'urgent') && status !== 'done') {
          const task = (row[taskIdx] || '').toString().trim();
          const desc = (row[descIdx] || '').toString().trim();
          urgentRows.push({ row: i + 1, task, desc, urgency, status });
        }
      }
      if (!urgentRows.length) return 'No urgent items found in that tab.';
      const lines = urgentRows.map((r, idx) => `${idx+1}. Row ${r.row}: ${r.task || r.desc || '(no task text)'}${r.desc ? ' — ' + r.desc : ''}`);
      return `Found ${urgentRows.length} urgent item(s):\n` + lines.join('\n');
    }

    async function startRealtime() {
      try {
        setStatus('requesting mic…');
        try {
          if ('permissions' in navigator && navigator.permissions?.query) {
            const p = await navigator.permissions.query({ name: 'microphone' });
            log('[PERM] microphone:', p.state);
          }
        } catch (e) {}

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mic = stream;
        const micTrack = mic.getTracks()[0];

        pc = new RTCPeerConnection();
        pc.oniceconnectionstatechange = () => log('ICE:', pc.iceConnectionState);
        pc.onconnectionstatechange = () => log('PC:', pc.connectionState);
        pc.ontrack = (e) => {
          log('[RT] ontrack: remote audio');
          audioEl.srcObject = e.streams[0];
          audioEl.play().catch(err => log('[AUDIO] play blocked:', err?.message || err));
        };

        const tx = pc.addTransceiver('audio', { direction: 'sendrecv' });
        try { await tx.sender.replaceTrack(micTrack); } catch {}
        if (tx.sender.setStreams) { try { tx.sender.setStreams(mic); } catch {} }

        dc = pc.createDataChannel('oai-events');
        window.dc = dc;

        let sessionIsCreated = false;
        let sessionIsUpdated = false;

        dc.onopen = () => {
          log('[DC] open');
          setSendReady(true);
          setStatus('waiting-for-session');
        };

        dc.onmessage = (evt) => {
          let msg;
          try { msg = JSON.parse(evt.data); } catch (e) { return; }
          log('[DC<=]', msg);

          if (msg.type === 'response.created' && msg.response && msg.response.id) {
            if (window.__waitingForResponseId) {
              window.__lastResponseCreatedId = msg.response.id;
              window.__waitingForResponseId = false;
              log('[INFO] captured response id', window.__lastResponseCreatedId);
            }
          }

          if (msg.type === 'response.done' && msg.response_id) {
            if (!window.__lastResponseCreatedId || msg.response_id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.done -> cleared __responseActive');
              flushPendingToolResults();
            }
          }
          if (msg.type === 'response.completed' && msg.response_id) {
            if (!window.__lastResponseCreatedId || msg.response_id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.completed -> cleared __responseActive');
              flushPendingToolResults();
            }
          }
          if (msg.type === 'response.output_item.completed' && msg.response_id) {
            if (!window.__lastResponseCreatedId || msg.response_id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.output_item.completed -> cleared __responseActive');
              flushPendingToolResults();
            }
          }

          if (msg.type === 'session.created') {
            sessionIsCreated = true;

            const sessionUpdate = {
              type: 'session.update',
              session: {
                voice: 'alloy',
                temperature: 0.6,
                turn_detection: {
                  type: 'server_vad',
                  threshold: 0.7,
                  prefix_padding_ms: 400,
                  silence_duration_ms: 1500,
                  idle_timeout_ms: 10000,
                  create_response: false,
                  interrupt_response: true
                },
                instructions:
                            'Your name is Nyx. Speak English by default. Be concise, factual, and friendly. ' +
                            'Never invent information or guess; if you do not know, say so. ' +
                            'If a task is outside your ability, say so clearly. Always tell the truth and avoid speculation. ' +
                            'When you need current or external information (news, web content, live data), call the web_search tool with an appropriate query instead of guessing. ' +
                            'Prioritize listening over talking; wait briefly after the user stops before replying. ' +
                            'If the user starts speaking while you are talking, stop immediately. ' +
                            'Use registered tools (Docs, Drive, web_search) whenever they are relevant and state their results exactly.'
              }
            };
            try {
              dc.send(JSON.stringify(sessionUpdate));
              log('[DC=>] session.update sent');
            } catch (e) {
              log('[ERR] sending session.update', e?.message || e);
            }
            return;
          }

          if (msg.type === 'session.updated') {
            sessionIsUpdated = true;
            setStatus('ready');

                        // Register Docs tools AFTER instructions are applied
            if (!window.__toolsRegistered) {
              window.__toolsRegistered = true;

              window.toolArgBuf = Object.create(null);

              // Dispatcher: routes tool calls to your backend (Docs baseline)
              window.handleToolCall = async function handleToolCall(name, args, callId) {
                try {
                  let url = '', body = {};

                  if (name === 'docs_read') {
                    url = '/api/workspace.js?action=docs.read';
                    body = {
                      docId: (args.docId || '').toString(),
                      docName: (args.docName || '').toString(),
                      folderName: (args.folderName || '').toString()
                    };
                    const r = await fetch(url, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      credentials: 'include',
                      body: JSON.stringify(body)
                    });
                    const text = await r.text();
                    log('[TOOL] docs_read', r.status, text.slice(0, 400));
                    await sendResponseInstructions(text);
                    return;
                  } else if (name === 'docs_createappend') {
                    url = '/api/workspace.js?action=docs.createappend';
                    body = {
                      docName: (args.docName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      text: (args.text ?? '').toString()
                    };
                    const r = await fetch(url, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      credentials: 'include',
                      body: JSON.stringify(body)
                    });
                    const text = await r.text();
                    log('[TOOL] docs_createappend', r.status, text.slice(0, 400));
                    await sendResponseInstructions(`OK — appended to ${body.docName || '(unnamed)'} (status ${r.status}).`);
                    return;
                  }

                  // Unsupported tool (may be extended below by Drive add-on)
                  const out = { error: `Unsupported tool: ${name}` };
                  await sendResponseInstructions(JSON.stringify(out));
                } catch (e) {
                  const out = { error: String(e?.message || e) };
                  await sendResponseInstructions(JSON.stringify(out));
                }
              };

              // Register just the Docs tools
              const toolsUpdate = {
                type: 'session.update',
                session: {
                  tool_choice: 'auto',
                  tools: [
                    {
                      type: 'function',
                      name: 'docs_read',
                      description: 'Read a Google Doc by name (optional folderName). Returns contents.',
                      parameters: {
                        type: 'object',
                        properties: {
                          docId: { type: 'string', description: 'Optional Google Doc ID (preferred if known)' },
                          docName: { type: 'string', description: 'Document name to read' },
                          folderName: { type: 'string', description: 'Optional parent folder; omit for root' }
                        },
                        required: ['docName']
                      }
                    },
                    {
                      type: 'function',
                      name: 'docs_createappend',
                      description: 'Create a Doc in root (or optional folder) if missing, then append text to it.',
                      parameters: {
                        type: 'object',
                        properties: {
                          docName: { type: 'string', description: 'Target document name' },
                          folderName: { type: 'string', description: 'Optional parent folder; omit for root' },
                          text: { type: 'string', description: 'Text to append (newline is added if missing)' }
                        },
                        required: ['docName', 'text']
                      }
                    }
                  ]
                }
              };

              try {
                dc.send(JSON.stringify(toolsUpdate));
                log('[DC=>] tools session.update (Docs) sent');
              } catch (e) {
                log('[ERR] sending tools session.update', e?.message || e);
              }
              

              /* === DRIVE ADD-ON (merge-safe) ===
                 Inserted right after the Docs registration above.
                 - Merges a `drive_search` tool with the existing tools list (no overwrite)
                 - Extends the dispatcher to handle drive_search
              */
              try {
                // Keep a shared tool list so later updates merge instead of overwrite
                window.__tools = window.__tools || (toolsUpdate?.session?.tools ? toolsUpdate.session.tools.slice() : []);

                function __mergeTools(add) {
                  const byName = new Set((window.__tools || []).map(t => t.name));
                  (add || []).forEach(t => { if (!byName.has(t.name)) { window.__tools.push(t); byName.add(t.name); } });
                  return window.__tools;
                }

                // Preserve the Docs dispatcher; prepend Drive handling
                const __prevDispatch = window.handleToolCall;
                window.handleToolCall = async function(name, args, callId) {
                  if (name === 'drive_search') {
                    try {
                      const body = {
                        name: (args?.name || '').toString(),            // partial name (optional)
                        folderName: (args?.folderName || '').toString(),// optional folder scope
                        mimeType: (args?.mimeType || '').toString(),    // e.g. folders: application/vnd.google-apps.folder
                        pageSize: Math.max(1, Math.min(Number(args?.pageSize || 50), 200))
                      };
                      const r = await fetch('/api/workspace.js?action=drive.search', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify(body)
                      });
                      const text = await r.text();

                      // Return results to assistant; Nyx will speak/print them
                      await sendResponseInstructions(text);
                      return; // handled
                    } catch (e) {
                      await sendResponseInstructions(JSON.stringify({ error: String(e?.message || e) }));
                      return; // handled with error
                    }
                  }
                  // Fall-through to Docs tools
                  if (typeof __prevDispatch === 'function') return __prevDispatch(name, args, callId);
                };

                // Merge and register Drive tool without clobbering Docs
                const merged = __mergeTools([
                  {
                    type: 'function',
                    name: 'drive_search',
                    description: "Search Google Drive for files/folders by partial name and/or mimeType, optionally inside a named folder.",
                    parameters: {
                      type: 'object',
                      properties: {
                        name: { type: 'string', description: "Partial name (e.g. 'invoice') — optional" },
                        folderName: { type: 'string', description: "Optional parent folder name" },
                        mimeType: { type: 'string', description: "e.g. 'application/vnd.google-apps.folder' for folders, 'application/vnd.google-apps.spreadsheet' for Sheets" },
                        pageSize: { type: 'integer', minimum: 1, maximum: 200 }
                      },
                      required: []
                    }
                  }
                ]);

                dc.send(JSON.stringify({
                  type: 'session.update',
                  session: { tool_choice: 'auto', tools: merged }
                }));
                log('[DC=>] tools session.update (Docs + Drive) sent');
              } catch (e) {
                log('[ERR] drive add-on setup', e?.message || e);
              }
              /* === END DRIVE ADD-ON === */
            }
            // --- Single guarded greeting + re-enable auto VAD ---
if (!window.__greeted) {
  window.__greeted = true;

  // Force initial spoken line so audio is confirmed
  dc.send(JSON.stringify({
    type: 'response.create',
    response: {
      instructions: 'Hello, I am Nyx. Awesome tea cosy.'
    }
  }));
  log('[DC=>] response.create (audio test greeting)');

  // Now re-enable VAD auto responses for normal flow
  dc.send(JSON.stringify({
    type: 'session.update',
    session: {
      turn_detection: {
        type: 'server_vad',
        threshold: 0.7,
        prefix_padding_ms: 400,
        silence_duration_ms: 1500,
        idle_timeout_ms: 10000,
        create_response: true,
        interrupt_response: true
      }
    }
  }));
  log('[DC=>] session.update (re-enable auto VAD)');
}
            return;
          }

          // Handle streamed tool-call arguments (only after tools are registered)
          
          {
            const t = msg.type;

            const isDelta =
              t === 'response.function_call_arguments.delta' ||
              t === 'response.function_call.arguments.delta' ||
              t === 'response.tool_call.delta' ||
              t === 'response.tool_call.arguments.delta';

            const isDone =
              t === 'response.function_call_arguments.done' ||
              t === 'response.function_call.completed' ||
              t === 'response.tool_call.completed' ||
              t === 'response.tool_call.arguments.done';

            if ((isDelta || isDone) && !window.__toolsRegistered) {
              return;
            }

            if (isDelta) {
              const id = msg.call_id || msg.id;
              const frag =
                (typeof msg.delta === 'string' ? msg.delta :
                 typeof msg.arguments === 'string' ? msg.arguments : '');
              window.toolArgBuf = window.toolArgBuf || Object.create(null);
              window.toolArgBuf[id] = (window.toolArgBuf[id] || '') + frag;
              return;
            }

            if (isDone) {
              const id = msg.call_id || msg.id;
              const name = msg.name || msg.tool_name;
              const argsStr =
                (typeof msg.arguments === 'string' ? msg.arguments : (window.toolArgBuf ? window.toolArgBuf[id] : '')) || '{}';
              if (window.toolArgBuf) delete window.toolArgBuf[id];

              let args = {};
              try { args = JSON.parse(argsStr); } catch (e) { args = {}; }
              if (typeof window.handleToolCall === 'function') {
                window.handleToolCall(name, args, id);
              }
              return;
            }
          }

          if (msg.type === 'error') {
            console.error('[Realtime ERROR]', msg.error || msg);
            setStatus('error');
            return;
          }
        };

        dc.onerror = (e) => log('[DC] error', e);
        dc.onclose = () => { log('[DC] closed'); setSendReady(false); setStatus('disconnected'); };

        setStatus('creating offer…');
        const offer = await pc.createOffer({ offerToReceiveAudio: 1 });
        await pc.setLocalDescription(offer);

        const res = await fetch('/api/realtime/offer.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp' },
          body: offer.sdp,
          credentials: 'include'
        });
        const answer = await res.text();
        log('[HTTP] /api/realtime/offer →', res.status);
        if (!res.ok) {
          try { log('[ERR]', JSON.parse(answer)); } catch { log('[ERR]', answer); }
          throw new Error('Offer→Answer failed');
        }

        await pc.setRemoteDescription({ type: 'answer', sdp: answer });
        setStatus('connected — waiting for channel…');
        log('[RT] connected; speak to the assistant…');
      } catch (e) {
        setStatus('error');
        log('[EXC] startRealtime:', e?.message || e);
        throw e;
      }
    }

    function stopRealtime() {
      try { pc?.getSenders().forEach(s => s.track?.stop()); pc?.close(); } catch {}
      try { mic?.getTracks().forEach(t => t.stop()); } catch {}
      pc = null; mic = null; dc = null; window.dc = null; audioEl.srcObject = null;
      setSendReady(false);
      setStatus('idle');
      window.__responseActive = false;
      window.__waitingForResponseId = false;
      window.__lastResponseCreatedId = null;
      window.__pendingToolResults = [];
      log('[RT] stopped');
    }

    async function ensureGoogleAuth() {
      try {
        const r = await fetch('/api/google.js?op=status', { credentials: 'include' });
        const data = await r.json();
        log('[AUTH]', data);
        if (data.connected && !data.refresh_problem) return true;
        setStatus('connecting Google…');
        window.location.href = '/api/google.js?op=start';
        return false;
      } catch (e) {
        log('[AUTH] status error:', e?.message || e);
        window.location.href = '/api/google.js?op=start';
        return false;
      }
    }

    btn.addEventListener('click', async () => {
      btn.disabled = true;
      try {
        if (!live) {
          btnLabel.textContent = 'Connecting…';
          const ok = await ensureGoogleAuth();
          if (!ok) return;
          await startRealtime();
          live = true;
          btnLabel.textContent = 'Stop';
        } else {
          stopRealtime();
          live = false;
          btnLabel.textContent = 'Start';
        }
      } catch {
        stopRealtime();
        live = false;
        btnLabel.textContent = 'Start';
      } finally {
        btn.disabled = false;
      }
    });

    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); if (!sendBtn.disabled) sendBtn.click(); }
    });
  </script>
  <script type="module">
/* === OPTIONAL WEB SEARCH TOOLS (SerpAPI via /api/workspace.js?action=web.search) === */
(function(){
  const DEBUG = true;
  function dbg(...a){ if (DEBUG) console.log('[WEB-SEARCH]', ...a); }

  // Send a normal assistant message with the results (no dependency on other modules)
  async function speakToAssistant(text){
    try{
      if(!window.dc || window.dc.readyState !== 'open'){ dbg('dc not open'); return; }
      window.dc.send(JSON.stringify({ type:'response.create', response:{ instructions: String(text) }}));
    }catch(e){ console.error('[WEB-SEARCH] speak err', e); }
  }

  async function callWebSearch(args){
    const body = {
      query: (args?.query || '').toString(),
      num: Math.max(1, Math.min(Number(args?.num ?? 5), 10)),
      site: (args?.site || '').toString(),
      freshnessDays: Math.max(0, Math.min(Number(args?.freshnessDays ?? 0), 365))
    };
    if(!body.query){ await speakToAssistant('web_search: query is required'); return; }

    const r = await fetch('/api/workspace.js?action=web.search', {
      method:'POST', headers:{'Content-Type':'application/json'},
      credentials:'include', body: JSON.stringify(body)
    });
    const raw = await r.text();
    dbg('web.search', r.status, raw.slice(0,300));

    // Format a friendly summary if JSON, otherwise relay raw text
    try{
      const j = JSON.parse(raw);
      if(Array.isArray(j.results) && j.results.length){
        const lines = j.results.map((it,i)=>`${i+1}. ${it.title}\n   ${it.url}\n   – ${it.snippet||''}`);
        await speakToAssistant(`Top ${j.results.length} result(s):\n` + lines.join('\n'));
        return;
      }
      await speakToAssistant(raw);
    }catch{
      await speakToAssistant(raw);
    }
  }

  // Wrap handleToolCall so the VA can invoke "web_search"
  const prev = window.handleToolCall;
  window.handleToolCall = async function(name, args, callId){
    if(name === 'web_search'){ await callWebSearch(args||{}); return; }
    if(typeof prev === 'function') return prev(name, args, callId);
  };

  // Register the tool with the model once DataChannel is open (retry politely)
  function registerTool(){
    if(!window.dc || window.dc.readyState !== 'open') return false;
    const payload = {
      type:'session.update',
      session:{
        tool_choice:'auto',
        tools:[{
          type:'function',
          name:'web_search',
          description:'Searches the public web and returns summarized results.',
          parameters:{
            type:'object',
            properties:{
              query:{type:'string', description:'Search query text'},
              num:{type:'integer', minimum:1, maximum:10, description:'How many results (default 5)'},
              site:{type:'string', description:'Optional site filter, e.g. example.com'},
              freshnessDays:{type:'integer', minimum:0, maximum:365, description:'Only recent results (0 = any time)'}
            },
            required:['query']
          }
        }]
      }
    };
    try{ window.dc.send(JSON.stringify(payload)); dbg('tool registered'); return true; }
    catch(e){ console.error('[WEB-SEARCH] register err', e); return false; }
  }

  // Try immediately, then poll briefly until dc opens
  if(!registerTool()){
    let tries = 0;
    const t = setInterval(()=>{ tries++; if(registerTool() || tries>30) clearInterval(t); }, 1000);
  }
})();
</script>
</body>
</html>
