<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phoenix VA — Realtime</title>
  <meta name="color-scheme" content="light dark" />
  <style>
    :root {
      --navy: #0B1B34;
      --card: #0F223F;
      --text: #E8EEF9;
      --muted: #9FB1D1;
      --accent: #FFFFFF;
      --btn-bg: #001F3F;
      --btn-tx: #FFFFFF;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      background: var(--navy);
      color: var(--text);
      display: grid;
      place-items: center;
      min-height: 100svh;
    }
    .wrap { width: 100%; max-width: 720px; padding: 20px; display: grid; gap: 16px; }
    .brand { display: grid; place-items: center; gap: 10px; text-align: center; }
    .brand img {
      width: 96px; height: auto; display: block;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,.25));
      user-select: none;
    }
    .brand h1 { margin: 0; font-size: 18px; font-weight: 600; color: var(--muted); letter-spacing: .3px; }
    .card {
      background: color-mix(in oklab, var(--card) 90%, black 10%);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, .btn {
      appearance: none; border: none; background: #F4F6FC; color: #0B1B34;
      padding: 10px 14px; border-radius: 12px; font-weight: 700; cursor: pointer;
      transition: transform .04s ease, opacity .2s ease, background .2s ease;
    }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #voiceToggle {
      background: var(--btn-bg); color: var(--btn-tx);
      display: inline-flex; align-items: center; gap: 10px;
      padding: 12px 18px; border-radius: 16px;
    }
    #voiceToggle:hover { background: #003366; }
    .btn-outline { background: transparent; color: var(--accent); border: 1px solid rgba(255,255,255,.2); }
    input[type="text"] {
      flex: 1 1 220px; background: rgba(255,255,255,.06); color: var(--text);
      border: 1px solid rgba(255,255,255,.15); border-radius: 10px; padding: 10px 12px; outline: none;
    }
    input::placeholder { color: rgba(255,255,255,.5); }

    /* Tabs + panels */
    .tabs {
      display: flex;
      gap: 4px;
      margin-top: 12px;
      margin-bottom: 4px;
    }
    .tab-btn {
      flex: 0 0 auto;
      border-radius: 12px 12px 0 0;
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      border: 1px solid transparent;
      cursor: pointer;
    }
    .tab-btn.active {
      background: rgba(0,0,0,0.3);
      color: var(--accent);
      border-color: rgba(255,255,255,0.15);
      border-bottom-color: transparent;
    }
    .panel {
      border-radius: 0 10px 10px 10px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.25);
      padding: 10px 12px;
      max-height: 280px;
      overflow: auto;
      display: none;
    }
    .panel.active { display: block; }

    #chat {
      font-size: 13px;
      line-height: 1.4;
    }
    .msg {
      margin-bottom: 6px;
    }
    .msg span.role {
      font-weight: 600;
      margin-right: 4px;
      color: var(--muted);
    }

    #log {
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px; line-height: 1.4; color: #CFE2FF;
    }
    .hint { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="brand">
      <img src="/public/logo.png" alt="Phoenix VA Logo" />
      <h1>Phoenix VA</h1>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <button id="voiceToggle">
            <span id="voiceLabel">Start</span>
          </button>
        </div>
        <span class="hint" id="status">idle</span>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="textInput" type="text" placeholder="Ask me anything">
        <button id="sendText">Send</button>
      </div>

      <audio id="assistantAudio" autoplay playsinline style="display:none"></audio>

      <!-- Tabs + panels -->
      <div class="tabs">
        <button class="tab-btn active" data-tab="chat">Conversation</button>
        <button class="tab-btn" data-tab="log">Logs</button>
      </div>
      <div id="chat" class="panel active"></div>
      <div id="log" class="panel"></div>
    </div>
  </div>

  <script type="module">
    const logEl = document.getElementById('log');
    const chatEl = document.getElementById('chat');
    const statusEl = document.getElementById('status');
    const btn = document.getElementById('voiceToggle');
    const btnLabel = document.getElementById('voiceLabel');
    const inputEl = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendText');
    const audioEl = document.getElementById('assistantAudio');

    const setSendReady = (ready) => { sendBtn.disabled = !ready; };
    setSendReady(false);

    // Conversation helpers
    function appendChat(role, text, replaceLastForRole = false) {
      if (!text) return;
      if (replaceLastForRole) {
        for (let i = chatEl.children.length - 1; i >= 0; i--) {
          const node = chatEl.children[i];
          if (node.dataset && node.dataset.role === role) {
            const spanText = node.querySelector('.content');
            spanText.textContent += text;
            chatEl.scrollTop = chatEl.scrollHeight;
            return;
          }
        }
      }
      const div = document.createElement('div');
      div.className = 'msg';
      div.dataset.role = role;
      const label = document.createElement('span');
      label.className = 'role';
      label.textContent = role === 'user' ? 'Rijk:' : 'Nyx:';
      const content = document.createElement('span');
      content.className = 'content';
      content.textContent = text;
      div.appendChild(label);
      div.appendChild(content);
      chatEl.appendChild(div);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // Helper: extract text from Realtime delta objects
    function extractTextFromDelta(delta) {
      if (!delta) return '';
      if (typeof delta === 'string') return delta;

      // For audio transcript events: { transcript: "..." }
      if (typeof delta.transcript === 'string') return delta.transcript;

      // Generic content array shape: { content: [ { type, text }, ... ] }
      if (Array.isArray(delta.content)) {
        return delta.content
          .map(part => (typeof part.text === 'string' ? part.text : ''))
          .join('');
      }

      if (delta.output_text && typeof delta.output_text.text === 'string') {
        return delta.output_text.text;
      }
      if (delta.input_text && typeof delta.input_text.text === 'string') {
        return delta.input_text.text;
      }
      return '';
    }

    // Tabs
    document.querySelectorAll('.tab-btn').forEach(btnTab => {
      btnTab.addEventListener('click', () => {
        const tab = btnTab.dataset.tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b === btnTab));
        document.querySelectorAll('.panel').forEach(p => {
          p.classList.toggle('active', p.id === tab);
        });
      });
    });

    const log = (...a) => {
      const s = a.map(x => typeof x === 'string' ? x : JSON.stringify(x, null, 2)).join(' ');
      logEl.textContent += s + '\n';
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...a);
    };
    const setStatus = (s) => { statusEl.textContent = s; };

    let pc = null, mic = null, dc = null, live = false;

    // Response state management
    window.__responseActive = false;
    window.__waitingForResponseId = false;
    window.__lastResponseCreatedId = null;
    window.__pendingToolResults = [];

    const RESPONSE_ACTIVE_FALLBACK_MS = 12000;
    let __responseActiveFallbackTimer = null;
    function setResponseActive(active) {
      window.__responseActive = !!active;
      if (active) {
        clearTimeout(__responseActiveFallbackTimer);
        __responseActiveFallbackTimer = setTimeout(() => {
          if (window.__responseActive) {
            log('[WARN] responseActive fallback fired; clearing flag');
            window.__responseActive = false;
            window.__waitingForResponseId = false;
            window.__lastResponseCreatedId = null;
            flushPendingToolResults();
          }
        }, RESPONSE_ACTIVE_FALLBACK_MS);
      } else {
        clearTimeout(__responseActiveFallbackTimer);
        __responseActiveFallbackTimer = null;
      }
    }

    async function sendResponseInstructions(text) {
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DC not open; cannot send response.create');
        return;
      }
      if (window.__responseActive) {
        window.__pendingToolResults.push({ text });
        log('[INFO] response active — queued tool result');
        return;
      }
      try {
        window.__waitingForResponseId = true;
        setResponseActive(true);
        dc.send(JSON.stringify({
          type: 'response.create',
          response: { instructions: text }
        }));
        log('[DC=>] response.create (tool output sent)');
      } catch (e) {
        log('[ERR] sendResponseInstructions send failed:', e?.message || e);
        setResponseActive(false);
        window.__waitingForResponseId = false;
      }
    }

    function flushPendingToolResults() {
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DC not open; cannot flush pending tool results');
        return;
      }
      if (window.__responseActive) {
        log('[INFO] still response active; will flush later');
        return;
      }
      const item = window.__pendingToolResults.shift();
      if (item) {
        log('[INFO] flushing queued tool result');
        sendResponseInstructions(item.text);
      }
    }

    // Text send (typed)
    sendBtn.addEventListener('click', () => {
      const text = (inputEl.value || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DataChannel not open yet; cannot send text.');
        return;
      }
      appendChat('user', text);
      try {
        dc.send(JSON.stringify({ type: 'response.create', response: { instructions: text }}));
        log('[TX] text prompt → response.create');
      } catch (e) {
        log('[ERR] send text:', e?.message || e);
      }
      inputEl.value = '';
    });

    async function startRealtime() {
      try {
        setStatus('requesting mic…');
        try {
          if ('permissions' in navigator && navigator.permissions?.query) {
            const p = await navigator.permissions.query({ name: 'microphone' });
            log('[PERM] microphone:', p.state);
          }
        } catch (e) {}

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mic = stream;
        const micTrack = mic.getTracks()[0];

        pc = new RTCPeerConnection();
        pc.oniceconnectionstatechange = () => log('ICE:', pc.iceConnectionState);
        pc.onconnectionstatechange = () => log('PC:', pc.connectionState);
        pc.ontrack = (e) => {
          log('[RT] ontrack: remote audio');
          audioEl.srcObject = e.streams[0];
          audioEl.play().catch(err => log('[AUDIO] play blocked:', err?.message || err));
        };

        const tx = pc.addTransceiver('audio', { direction: 'sendrecv' });
        try { await tx.sender.replaceTrack(micTrack); } catch {}
        if (tx.sender.setStreams) { try { tx.sender.setStreams(mic); } catch {} }

        dc = pc.createDataChannel('oai-events');

        let sessionIsCreated = false;
        let sessionIsUpdated = false;

        // buffer of assistant text per response id
        const assistantTextBuffers = Object.create(null);

        dc.onopen = () => {
          log('[DC] open');
          setSendReady(true);
          setStatus('waiting-for-session');
        };

        dc.onmessage = (evt) => {
          let msg;
          try { msg = JSON.parse(evt.data); } catch (e) { return; }

          log('[DC<=]', msg);

          // USER: recognized input text streamed back by the model
          if (msg.type === 'response.input_text.delta') {
            const deltaText =
              (msg.delta && typeof msg.delta.text === 'string')
                ? msg.delta.text
                : extractTextFromDelta(msg.delta);
            if (deltaText) {
              appendChat('user', deltaText, true);
            }
          }

          // Assistant text from audio transcript
          if (msg.type === 'response.audio_transcript.delta') {
            const id = msg.response_id || 'default';
            const deltaText = extractTextFromDelta(msg.delta);
            if (deltaText) {
              assistantTextBuffers[id] = (assistantTextBuffers[id] || '') + deltaText;
              appendChat('assistant', deltaText, true);
            }
          }

          // Assistant text deltas (if the model ever sends them)
          if (msg.type === 'response.output_text.delta') {
            const id = msg.response_id || 'default';
            const deltaText = extractTextFromDelta(msg.delta);
            if (deltaText) {
              assistantTextBuffers[id] = (assistantTextBuffers[id] || '') + deltaText;
              appendChat('assistant', deltaText, true);
            }
          }

          if ((msg.type === 'response.completed' || msg.type === 'response.done') && msg.response_id) {
            delete assistantTextBuffers[msg.response_id];
          }

          if (msg.type === 'response.created' && msg.response && msg.response.id) {
            if (window.__waitingForResponseId) {
              window.__lastResponseCreatedId = msg.response.id;
              window.__waitingForResponseId = false;
              log('[INFO] captured response id', window.__lastResponseCreatedId);
            }
          }

          if (msg.type === 'response.done' && msg.response_id) {
            if (!window.__lastResponseCreatedId || msg.response_id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.done -> cleared __responseActive');
              flushPendingToolResults();
            }
          }
          if (msg.type === 'response.completed' && msg.response_id) {
            if (!window.__lastResponseCreatedId || msg.response_id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.completed -> cleared __responseActive');
              flushPendingToolResults();
            }
          }
          if ((msg.type === 'response.output_item.completed' ||
               msg.type === 'response.output_item.done') &&
              msg.response_id) {
            if (!window.__lastResponseCreatedId || msg.response_id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.output_item.* -> cleared __responseActive');
              flushPendingToolResults();
            }
          }

          if (msg.type === 'session.created') {
            sessionIsCreated = true;

            const sessionUpdate = {
              type: 'session.update',
              session: {
                voice: 'alloy',
                turn_detection: {
                  type: 'server_vad',
                  threshold: 0.85,
                  prefix_padding_ms: 400,
                  silence_duration_ms: 1200,
                  idle_timeout_ms: 10000,
                  create_response: true,
                  interrupt_response: false
                },
                instructions:
                  'Your name is Nyx. Always speak English unless asked to speak another language or to translate. Be concise, factual, and avoid flattery.' +
                  'You are a Phoenix Virtual Assistant, designed to help people deal with many administrative tasks, prioritizing voice first interaction.' +
                  'Do not discuss adult content, sexuality, terrorism, or gratuitous violence.' +
                  'Prefer tools over free-text answers for anything involving Drive/Docs/Sheets or external web search.'
              }
            };
            try {
              dc.send(JSON.stringify(sessionUpdate));
              log('[DC=>] session.update sent');
            } catch (e) {
              log('[ERR] sending session.update', e?.message || e);
            }
            return;
          }

          if (msg.type === 'session.updated') {
            sessionIsUpdated = true;
            setStatus('ready');

            if (!window.__greeted) {
              window.__greeted = true;
              try {
                dc.send(JSON.stringify({
                  type: 'response.create',
                  response: {
                    instructions: 'Say exactly the words: "Hi Rijk, you silly sausage."'
                  }
                }));
                log('[DC=>] response.create (greeting)');
              } catch (e) {
                log('[ERR] greeting send failed', e?.message || e);
              }
            }

            // Register tools AFTER instructions are applied
            if (!window.__toolsRegistered) {
              window.__toolsRegistered = true;

              window.toolArgBuf = Object.create(null);

              window.handleToolCall = async function handleToolCall(name, args, callId) {
                try {
                  let url = '', body = {};

                  if (name === 'docs_read') {
                    url = '/api/workspace.js?action=docs.read';
                    body = {
                      docId: (args.docId || '').toString(),
                      docName: (args.docName || '').toString(),
                      folderName: (args.folderName || '').toString()
                    };
                  } else if (name === 'docs_createappend') {
                    url = '/api/workspace.js?action=docs.createappend';
                    body = {
                      docId: (args.docId || '').toString(),
                      docName: (args.docName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      mode: (args.mode || 'append').toString(),
                      text: (args.text ?? '').toString()
                    };
                  } else if (name === 'drive_search') {
                    url = '/api/workspace.js?action=drive.search';
                    body = {
                      name: (args.name || '').toString(),
                      mimeType: (args.mimeType || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      pageSize: args.pageSize || 25
                    };
                  } else if (name === 'sheets_read') {
                    url = '/api/workspace.js?action=sheets.read';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || '').toString(),
                      range: (args.range || '').toString()
                    };
                  } else if (name === 'sheets_appendrow') {
                    url = '/api/workspace.js?action=sheets.appendrow';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || 'Sheet1').toString(),
                      values: Array.isArray(args.values) ? args.values : []
                    };
                  } else if (name === 'sheets_updatecell') {
                    url = '/api/workspace.js?action=sheets.updatecell';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || 'Sheet1').toString(),
                      cell: (args.cell || '').toString(),
                      value: args.value
                    };
                  } else if (name === 'web_search') {
                    url = '/api/workspace.js?action=web.search';
                    body = {
                      query: (args.query || '').toString(),
                      num: args.num || 5,
                      site: (args.site || '').toString(),
                      freshnessDays: args.freshnessDays || 0
                    };
                  } else if (name === 'drive_listroot') {
                    url = '/api/workspace.js?action=drive.listroot';
                    body = {};
                  } else {
                    const out = { error: `Unsupported tool: ${name}` };
                    await sendResponseInstructions(JSON.stringify(out));
                    return;
                  }

                  const r = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(body)
                  });

                  const text = await r.text();
                  log('[TOOL]', name, r.status, text.slice(0, 400));
                  await sendResponseInstructions(text);
                } catch (e) {
                  const out = { error: String(e?.message || e) };
                  await sendResponseInstructions(JSON.stringify(out));
                }
              };

              const toolsUpdate = {
                type: 'session.update',
                session: {
                  tool_choice: 'auto',
                  tools: [
                    {
                      type: 'function',
                      name: 'docs_read',
                      description: 'Read a Google Doc by name (optional folderName). Returns contents.',
                      parameters: {
                        type: 'object',
                        properties: {
                          docId: { type: 'string', description: 'Optional Google Doc ID (preferred if known)' },
                          docName: { type: 'string', description: 'Document name to read' },
                          folderName: { type: 'string', description: 'Optional parent folder; omit for root' }
                        },
                        required: ['docName']
                      }
                    },
                    {
                      type: 'function',
                      name: 'docs_createappend',
                      description: 'Create a Doc in root (or optional folder) if missing, then append or replace text.',
                      parameters: {
                        type: 'object',
                        properties: {
                          docId: { type: 'string', description: 'Optional Google Doc ID' },
                          docName: { type: 'string', description: 'Target document name' },
                          folderName: { type: 'string', description: 'Optional parent folder; omit for root' },
                          mode: { type: 'string', enum: ['append','replace'], description: 'append (default) or replace' },
                          text: { type: 'string', description: 'Text to write' }
                        },
                        required: ['text'],
                      }
                    },
                    {
                      type: 'function',
                      name: 'drive_search',
                      description: 'Search Google Drive for files/folders by name, mimeType, and optional folder.',
                      parameters: {
                        type: 'object',
                        properties: {
                          name: { type: 'string', description: 'Name fragment to search for' },
                          mimeType: { type: 'string', description: 'Optional mimeType filter' },
                          folderName: { type: 'string', description: 'Optional parent folder name' },
                          pageSize: { type: 'integer', description: 'Max results (1-200)', minimum: 1, maximum: 200 }
                        },
                        required: []
                      }
                    },
                    {
                      type: 'function',
                      name: 'drive_listroot',
                      description: 'List files in the root of My Drive.',
                      parameters: {
                        type: 'object',
                        properties: {},
                        required: []
                      }
                    },
                    {
                      type: 'function',
                      name: 'sheets_read',
                      description: 'Read a Sheet range given fileName, optional folderName, tab and range.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          range: { type: 'string', description: 'A1 range, e.g. A:Z or B2:G50' }
                        },
                        required: ['fileName']
                      }
                    },
                    {
                      type: 'function',
                      name: 'sheets_appendrow',
                      description: 'Append a row of values to a Sheet.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          values: { type: 'array', items: { type: 'string' }, description: 'Row values as array' }
                        },
                        required: ['fileName','values']
                      }
                    },
                    {
                      type: 'function',
                      name: 'sheets_updatecell',
                      description: 'Update a single cell in a Sheet.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          cell: { type: 'string', description: 'A1 cell reference, e.g. B7' },
                          value: { description: 'Value to write (any JSON type)' }
                        },
                        required: ['fileName','cell']
                      }
                    },
                    {
                      type: 'function',
                      name: 'web_search',
                      description: 'Perform a web search via SerpAPI and return summarized results.',
                      parameters: {
                        type: 'object',
                        properties: {
                          query: { type: 'string', description: 'Search query' },
                          num: { type: 'integer', description: 'Number of results (1-10)', minimum: 1, maximum: 10 },
                          site: { type: 'string', description: 'Optional site: filter, e.g. example.com' },
                          freshnessDays: { type: 'integer', description: 'Optional freshness limit in days', minimum: 0, maximum: 365 }
                        },
                        required: ['query']
                      }
                    }
                  ]
                }
              };

              try {
                dc.send(JSON.stringify(toolsUpdate));
                log('[DC=>] tools session.update sent');
              } catch (e) {
                log('[ERR] sending tools session.update', e?.message || e);
              }
            }
            return;
          }

          // Tool arguments streaming
          {
            const t = msg.type;

            const isDelta =
              t === 'response.function_call_arguments.delta' ||
              t === 'response.function_call.arguments.delta' ||
              t === 'response.tool_call.delta' ||
              t === 'response.tool_call.arguments.delta';

            const isDone =
              t === 'response.function_call_arguments.done' ||
              t === 'response.function_call.completed' ||
              t === 'response.tool_call.completed' ||
              t === 'response.tool_call.arguments.done';

            if ((isDelta || isDone) && !window.__toolsRegistered) {
              return;
            }

            if (isDelta) {
              const id = msg.call_id || msg.id;
              const frag =
                (typeof msg.delta === 'string' ? msg.delta :
                 typeof msg.arguments === 'string' ? msg.arguments : '');
              window.toolArgBuf = window.toolArgBuf || Object.create(null);
              window.toolArgBuf[id] = (window.toolArgBuf[id] || '') + frag;
              return;
            }

            if (isDone) {
              const id = msg.call_id || msg.id;
              const name = msg.name || msg.tool_name;
              const argsStr =
                (typeof msg.arguments === 'string' ? msg.arguments : (window.toolArgBuf ? window.toolArgBuf[id] : '')) || '{}';
              if (window.toolArgBuf) delete window.toolArgBuf[id];

              let args = {};
              try { args = JSON.parse(argsStr); } catch (e) { args = {}; }
              if (typeof window.handleToolCall === 'function') {
                window.handleToolCall(name, args, id);
              }
              return;
            }
          }

          if (msg.type === 'error') {
            console.error('[Realtime ERROR]', msg.error || msg);
            setStatus('error');
            return;
          }
        };

        dc.onerror = (e) => log('[DC] error', e);
        dc.onclose = () => { log('[DC] closed'); setSendReady(false); setStatus('disconnected'); };

        setStatus('creating offer…');
        const offer = await pc.createOffer({ offerToReceiveAudio: 1 });
        await pc.setLocalDescription(offer);

        const res = await fetch('/api/realtime/offer.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp' },
          body: offer.sdp,
          credentials: 'include'
        });
        const answer = await res.text();
        log('[HTTP] /api/realtime/offer →', res.status);
        if (!res.ok) {
          try { log('[ERR]', JSON.parse(answer)); } catch { log('[ERR]', answer); }
          throw new Error('Offer→Answer failed');
        }

        await pc.setRemoteDescription({ type: 'answer', sdp: answer });
        setStatus('connected — waiting for channel…');
        log('[RT] connected; speak to the assistant…');
      } catch (e) {
        setStatus('error');
        log('[EXC] startRealtime:', e?.message || e);
        throw e;
      }
    }

    function stopRealtime() {
      try { pc?.getSenders().forEach(s => s.track?.stop()); pc?.close(); } catch {}
      try { mic?.getTracks().forEach(t => t.stop()); } catch {}
      pc = null; mic = null; dc = null; audioEl.srcObject = null;
      setSendReady(false);
      setStatus('idle');
      window.__responseActive = false;
      window.__waitingForResponseId = false;
      window.__lastResponseCreatedId = null;
      window.__pendingToolResults = [];
      log('[RT] stopped');
    }

    async function ensureGoogleAuth() {
      try {
        const r = await fetch('/api/google.js?op=status', { credentials: 'include' });
        const data = await r.json();
        log('[AUTH]', data);
        if (data.connected && !data.refresh_problem) return true;
        setStatus('connecting Google…');
        window.location.href = '/api/google.js?op=start';
        return false;
      } catch (e) {
        log('[AUTH] status error:', e?.message || e);
        window.location.href = '/api/google.js?op=start';
        return false;
      }
    }

    btn.addEventListener('click', async () => {
      btn.disabled = true;
      try {
        if (!live) {
          btnLabel.textContent = 'Connecting…';
          const ok = await ensureGoogleAuth();
          if (!ok) return;
          await startRealtime();
          live = true;
          btnLabel.textContent = 'Stop';
        } else {
          stopRealtime();
          live = false;
          btnLabel.textContent = 'Start';
        }
      } catch {
        stopRealtime();
        live = false;
        btnLabel.textContent = 'Start';
      } finally {
        btn.disabled = false;
      }
    });

    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); if (!sendBtn.disabled) sendBtn.click(); }
    });
  </script>
</body>
</html>
