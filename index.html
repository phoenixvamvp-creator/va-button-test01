<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PhoenixVA ‚Äî Voice + Text Portal (Mobile-friendly)</title>
    <style>
      body { font-family: system-ui, Arial, sans-serif; margin: 40px; }
      h1 { margin-top: 0; }
      #row { margin: 8px 0; display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
      input[type="text"] { width: 360px; max-width: 100%; padding: 8px; font-size: 16px; }
      button { padding: 10px 16px; font-size: 16px; margin-right: 6px; }
      #output { margin-top: 16px; padding: 12px; border: 1px solid #ddd; min-height: 90px; white-space: pre-wrap; }
      #status { color:#555; }
      #diag { margin-top: 8px; font-size: 12px; color:#666; white-space: pre-wrap; max-height: 240px; overflow:auto; }
      .rt-container{ display:flex; align-items:center; gap:12px; padding:8px 12px; border:2px solid black; border-radius:16px; background:black; }
      .rt-label{ font-weight:700; font-size:18px; color:#b3132c; letter-spacing:.3px; }
      .rt-toggle{ position:relative; width:76px; height:40px; border-radius:999px; background:#222; border:2px solid #b3132c; cursor:pointer; display:inline-flex; align-items:center; padding:2px; transition:background .2s ease; }
      .rt-toggle[aria-checked="true"]{ background:#330000; }
      .rt-thumb{ width:34px; height:34px; border-radius:999px; background:#b3132c; transform: translateX(0); transition: transform .2s ease; }
      .rt-toggle[aria-checked="true"] .rt-thumb{ transform: translateX(36px); }
      .rt-badge{ font-size:12px; padding:4px 8px; border-radius:999px; background:black; color:#b3132c; border:1px solid #b3132c; }
      .rt-badge.off{ background:#111; color:#666; border-color:#333; }
      .rt-note{ font-size:12px; color:#b3132c; margin-left:4px; }
    </style>
  </head>
  <body>
    <h1>PhoenixVA ‚Äî Voice + Text Portal</h1>

    <div id="row">
      <button id="pressBtn">üéôÔ∏è Hold to Talk</button>
      <div class="rt-container" role="group" aria-label="CHAT toggle">
        <span class="rt-label">CHAT</span>
        <div id="rtToggle" class="rt-toggle" role="switch" aria-checked="false" tabindex="0" aria-label="Toggle CHAT mode">
          <div class="rt-thumb"></div>
        </div>
        <span id="rtBadge" class="rt-badge off">OFF</span>
        <span class="rt-note">Realtime loop active when ON</span>
      </div>
      <span id="status"></span>
    </div>

    <div id="row">
      <input id="textInput" type="text" placeholder="Type your message‚Ä¶" />
      <button id="sendBtn">Send</button>
    </div>

    <div id="output">Ready.</div>
    <div id="diag"></div>

    <script>
      const pressBtn  = document.getElementById('pressBtn');
      const sendBtn   = document.getElementById('sendBtn');
      const textInput = document.getElementById('textInput');
      const output    = document.getElementById('output');
      const statusEl  = document.getElementById('status');
      const diag      = document.getElementById('diag');
      const rtToggle  = document.getElementById('rtToggle');
      const rtBadge   = document.getElementById('rtBadge');

      function log(s){ diag.textContent += `\n${s}`; diag.scrollTop = diag.scrollHeight; }

      // MIME detect
      const CANDIDATE_MIMES = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/mp4;codecs=mp4a','audio/mpeg'];
      const supported = CANDIDATE_MIMES.find(t => {
        try { return window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t); }
        catch { return false; }
      }) || 'audio/webm';

      function blobToDataUrl(blob){
        return new Promise((resolve,reject)=>{
          const fr=new FileReader();
          fr.onload=()=>resolve(fr.result);
          fr.onerror=reject;
          fr.readAsDataURL(blob);
        });
      }
      async function speak(text){
        try{
          const r = await fetch('/speak',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ text, voice:'alloy' }) });
          if(!r.ok) return;
          const buf = await r.arrayBuffer();
          const url = URL.createObjectURL(new Blob([buf],{type:'audio/mpeg'}));
          const a = new Audio(url); a.play().catch(()=>{});
        }catch(e){ log(`TTS error: ${String(e)}`); }
      }

      // ---------------- Text ‚Üí Chat ----------------
      async function sendMessage(msg){
        output.textContent='Thinking‚Ä¶';
        try{
          const r=await fetch('/chat',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ message: msg }) });
          const data=await r.json();
          const reply=data.reply || data.error || '(no reply)';
          output.textContent=reply;
          await speak(reply);
        }catch{ output.textContent='Network error'; }
      }
      sendBtn.onclick=()=>{ const msg=textInput.value.trim(); if(!msg) return; textInput.value=''; sendMessage(msg); };
      textInput.addEventListener('keydown', e=>{ if(e.key==='Enter') sendBtn.click(); });

      // ---------------- Hold-to-talk (single shot) ----------------
      let mediaRecorder, audioChunks=[];
      async function startRecording() {
        if (!navigator.mediaDevices?.getUserMedia) { output.textContent='Mic not supported'; return; }
        const stream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:true, noiseSuppression:true, autoGainControl:true, channelCount:1 } });
        try { mediaRecorder=new MediaRecorder(stream,{ mimeType: supported }); } catch { mediaRecorder=new MediaRecorder(stream); }
        audioChunks=[];
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) audioChunks.push(e.data); };
        mediaRecorder.onstop = onStopped;
        mediaRecorder.start();
        log(`Recorder MIME (single): ${supported}`);
      }
      async function onStopped(){
        const blob=new Blob(audioChunks,{type:supported});
        if(!blob.size){ statusEl.textContent='No audio'; output.textContent='No audio captured.'; return; }
        statusEl.textContent='Transcribing‚Ä¶'; output.textContent='Transcribing‚Ä¶';

        try{
          const dataUrl = await blobToDataUrl(blob);
          const tr = await fetch('/transcribe',{
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ audio: dataUrl })
          });
          const ct = tr.headers.get('content-type') || '';
          const tdata = ct.includes('application/json') ? await tr.json() : { error: await tr.text() };

          if (!tr.ok || tdata.error) {
            output.textContent = 'Transcription error.';
            log(`[HOLD] transcribe server error: ${tdata.error || tr.statusText}`);
            statusEl.textContent = 'Error';
            return;
          }

          const text = (tdata.text || '').trim();
          if (!text) { statusEl.textContent='No speech'; output.textContent='No speech detected.'; return; }

          statusEl.textContent = 'Asking‚Ä¶';
          output.textContent = 'You said: ' + text + '\nThinking‚Ä¶';

          const cr = await fetch('/chat',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ message: text }) });
          const cdata = await cr.json();
          const reply = cdata.reply || '(no reply)';
          output.textContent = 'You said: ' + text + '\nAssistant: ' + reply;
          statusEl.textContent = 'Ready';
          await speak(reply);
        }catch(e){
          statusEl.textContent='Error';
          output.textContent='Error during transcription or chat.';
          log(`[HOLD] transcribe network error: ${String(e)}`);
        }
      }
      function stopRecording(){ if(mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop(); }
      pressBtn.onmousedown = async ()=>{ statusEl.textContent='Recording‚Ä¶ (hold)'; await startRecording(); };
      pressBtn.onmouseup   = ()=>{ statusEl.textContent='Processing‚Ä¶'; stopRecording(); };
      pressBtn.onmouseleave= ()=>{ if(mediaRecorder && mediaRecorder.state==='recording'){ statusEl.textContent='Processing‚Ä¶'; stopRecording(); } };
      pressBtn.ontouchstart= async (e)=>{ e.preventDefault(); statusEl.textContent='Recording‚Ä¶ (hold)'; await startRecording(); };
      pressBtn.ontouchend  = (e)=>{ e.preventDefault(); statusEl.textContent='Processing‚Ä¶'; stopRecording(); };

      // ---------------- CHAT realtime (batching + guarded fetch) ----------------
      let realtimeActive=false, rtStream=null, rtRecorder=null, rtInterval=null;
      let rtChunks=[], rtBufferText='';
      const SEND_MS=1200;

      async function startRealtime(){
        if(rtRecorder) return;
        statusEl.textContent='CHAT mode: listening‚Ä¶';
        rtBufferText=''; rtChunks=[];
        try{
          rtStream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:true, noiseSuppression:true, autoGainControl:true, channelCount:1 } });
          try{ rtRecorder=new MediaRecorder(rtStream,{ mimeType: supported }); }catch{ rtRecorder=new MediaRecorder(rtStream); }
          rtRecorder.ondataavailable = e => { if(e.data && e.data.size) rtChunks.push(e.data); };
          rtRecorder.start();
          rtInterval = setInterval(sendBatch, SEND_MS);
          log(`[CHAT] started (${supported}), batching every ${SEND_MS}ms`);
        }catch(err){
          log(`[CHAT] start error: ${String(err)}`);
          statusEl.textContent='CHAT error: mic unavailable';
          stopRealtime();
        }
      }
      async function stopRealtime(){
        try{ if(rtInterval) clearInterval(rtInterval); }catch{}
        rtInterval=null;
        try{ if(rtRecorder && rtRecorder.state!=='inactive') rtRecorder.stop(); }catch{}
        rtRecorder=null;
        try{ if(rtStream) rtStream.getTracks().forEach(t=>t.stop()); }catch{}
        rtStream=null;
        statusEl.textContent='CHAT OFF. Press-and-hold active.';
      }
      async function sendBatch(){
        if(!rtChunks.length) return;
        const seg = new Blob(rtChunks, { type: supported });
        rtChunks = [];
        const dataUrl = await blobToDataUrl(seg);
        try{
          const tr = await fetch('/transcribe',{
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ audio: dataUrl })
          });
          const ct = tr.headers.get('content-type') || '';
          const body = ct.includes('application/json') ? await tr.json() : { error: await tr.text() };

          if (!tr.ok || body.error) {
            log(`[CHAT] transcribe server error: ${body.error || tr.statusText}`);
            return;
          }
          const text = (body.text || '').trim();
          if (text) {
            rtBufferText = text;
            output.textContent = `You (live): ${rtBufferText}`;
          }
        }catch(e){
          log(`[CHAT] transcribe network error: ${String(e)}`);
        }
      }

      function setRealtimeActive(on){
        realtimeActive = !!on;
        rtToggle.setAttribute('aria-checked', realtimeActive ? 'true':'false');
        rtBadge.textContent = realtimeActive ? 'ON' : 'OFF';
        rtBadge.classList.toggle('off', !realtimeActive);
        if (realtimeActive) startRealtime(); else stopRealtime();
      }
      function toggleRealtime(){ setRealtimeActive(!(rtToggle.getAttribute('aria-checked')==='true')); }
      rtToggle.addEventListener('click', toggleRealtime);
      rtToggle.addEventListener('keydown', e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); toggleRealtime(); } });

      // init
      setRealtimeActive(false);
    </script>
  </body>
</html>
