<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phoenix VA — Realtime</title>
  <meta name="color-scheme" content="light dark" />
  <style>
    :root {
      --navy: #0B1B34;
      --card: #0F223F;
      --text: #E8EEF9;
      --muted: #9FB1D1;
      --accent: #FFFFFF;
      --btn-bg: #001F3F;
      --btn-tx: #FFFFFF;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      background: var(--navy);
      color: var(--text);
      display: grid;
      place-items: center;
      min-height: 100svh;
    }
    .wrap { width: 100%; max-width: 720px; padding: 20px; display: grid; gap: 16px; }
    .brand { display: grid; place-items: center; gap: 10px; text-align: center; }
    .brand img {
      width: 96px; height: auto; display: block;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,.25));
      user-select: none;
    }
    .brand h1 { margin: 0; font-size: 18px; font-weight: 600; color: var(--muted); letter-spacing: .3px; }
    .card {
      background: color-mix(in oklab, var(--card) 90%, black 10%);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, .btn {
      appearance: none; border: none; background: #F4F6FC; color: #0B1B34;
      padding: 10px 14px; border-radius: 12px; font-weight: 700; cursor: pointer;
      transition: transform .04s ease, opacity .2s ease, background .2s ease;
    }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #voiceToggle {
      background: var(--btn-bg); color: var(--btn-tx);
      display: inline-flex; align-items: center; gap: 10px;
      padding: 12px 18px; border-radius: 16px;
    }
    #voiceToggle:hover { background: #003366; }
    .btn-outline { background: transparent; color: var(--accent); border: 1px solid rgba(255,255,255,.2); }
    input[type="text"] {
      flex: 1 1 220px; background: rgba(255,255,255,.06); color: var(--text);
      border: 1px solid rgba(255,255,255,.15); border-radius: 10px; padding: 10px 12px; outline: none;
    }
    input::placeholder { color: rgba(255,255,255,.5); }

    /* Tabs + panels */
    .tabs {
      display: flex;
      gap: 4px;
      margin-top: 12px;
      margin-bottom: 4px;
    }
    .tab-btn {
      flex: 0 0 auto;
      border-radius: 12px 12px 0 0;
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      border: 1px solid transparent;
      cursor: pointer;
    }
    .tab-btn.active {
      background: rgba(0,0,0,0.3);
      color: var(--accent);
      border-color: rgba(255,255,255,0.15);
      border-bottom-color: transparent;
    }
    .panel {
      border-radius: 0 10px 10px 10px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.25);
      padding: 10px 12px;
      max-height: 280px;
      overflow: auto;
      display: none;
    }
    .panel.active { display: block; }

    #chat {
      font-size: 13px;
      line-height: 1.4;
    }
    .msg { margin-bottom: 6px; }
    .msg span.role {
      font-weight: 600;
      margin-right: 4px;
      color: var(--muted);
    }

    #log {
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px; line-height: 1.4; color: #CFE2FF;
    }
    .hint { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="brand">
      <img src="/public/logo.png" alt="Phoenix VA Logo" />
      <h1>Phoenix VA</h1>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <button id="voiceToggle">
            <span id="voiceLabel">Start</span>
          </button>
        </div>
        <span class="hint" id="status">idle</span>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="textInput" type="text" placeholder="Ask me anything">
        <button id="sendText">Send</button>
      </div>

      <audio id="assistantAudio" autoplay playsinline style="display:none"></audio>

      <!-- Tabs + panels -->
      <div class="tabs">
        <button class="tab-btn active" data-tab="chat">Conversation</button>
        <button class="tab-btn" data-tab="log">Logs</button>
      </div>
      <div id="chat" class="panel active"></div>
      <div id="log" class="panel"></div>
    </div>
  </div>

  <script type="module">
    const logEl = document.getElementById('log');
    const chatEl = document.getElementById('chat');
    const statusEl = document.getElementById('status');
    const btn = document.getElementById('voiceToggle');
    const btnLabel = document.getElementById('voiceLabel');
    const inputEl = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendText');
    const audioEl = document.getElementById('assistantAudio');

    const setSendReady = (ready) => { sendBtn.disabled = !ready; };
    setSendReady(false);

    // Conversation helpers
    function appendChat(role, text, replaceLastForRole = false) {
      if (!text) return;

      if (replaceLastForRole) {
        for (let i = chatEl.children.length - 1; i >= 0; i--) {
          const node = chatEl.children[i];
          if (node.dataset && node.dataset.role === role) {
            const spanText = node.querySelector('.content');
            spanText.textContent += text;
            chatEl.scrollTop = chatEl.scrollHeight;
            return;
          }
        }
      }

      const div = document.createElement('div');
      div.className = 'msg';
      div.dataset.role = role;

      const label = document.createElement('span');
      label.className = 'role';
      label.textContent = role === 'user' ? 'Rijk:' : 'Nyx:';

      const content = document.createElement('span');
      content.className = 'content';
      content.textContent = text;

      div.appendChild(label);
      div.appendChild(content);
      chatEl.appendChild(div);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // Helper: extract text from Realtime delta objects
    function extractTextFromDelta(delta) {
      if (!delta) return '';
      if (typeof delta === 'string') return delta;

      if (typeof delta.transcript === 'string') return delta.transcript;

      if (Array.isArray(delta.content)) {
        return delta.content
          .map(part => (typeof part.text === 'string' ? part.text : ''))
          .join('');
      }

      if (delta.output_text && typeof delta.output_text.text === 'string') return delta.output_text.text;
      if (delta.input_text && typeof delta.input_text.text === 'string') return delta.input_text.text;

      return '';
    }

    // Tabs
    document.querySelectorAll('.tab-btn').forEach(btnTab => {
      btnTab.addEventListener('click', () => {
        const tab = btnTab.dataset.tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b === btnTab));
        document.querySelectorAll('.panel').forEach(p => p.classList.toggle('active', p.id === tab));
      });
    });

    const log = (...a) => {
      const s = a.map(x => typeof x === 'string' ? x : JSON.stringify(x, null, 2)).join(' ');
      logEl.textContent += s + '\n';
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...a);
    };

    const setStatus = (s) => { statusEl.textContent = s; };

    let pc = null, mic = null, dc = null, live = false;

    // Response state management (prevents overlapping tool-result responses)
    window.__responseActive = false;
    window.__waitingForResponseId = false;
    window.__lastResponseCreatedId = null;
    window.__pendingToolResults = [];

    const RESPONSE_ACTIVE_FALLBACK_MS = 12000;
    let __responseActiveFallbackTimer = null;

    function setResponseActive(active) {
      window.__responseActive = !!active;
      if (active) {
        clearTimeout(__responseActiveFallbackTimer);
        __responseActiveFallbackTimer = setTimeout(() => {
          if (window.__responseActive) {
            log('[WARN] responseActive fallback fired; clearing flag');
            window.__responseActive = false;
            window.__waitingForResponseId = false;
            window.__lastResponseCreatedId = null;
            flushPendingToolResults();
          }
        }, RESPONSE_ACTIVE_FALLBACK_MS);
      } else {
        clearTimeout(__responseActiveFallbackTimer);
        __responseActiveFallbackTimer = null;
      }
    }

    // Send tool output back to the model as "instructions"
    // Hard rule: if tool returns ok:false or invalid JSON, model must say so and not guess.
    async function sendToolResultToModel(rawText, sourceHint) {
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DC not open; cannot send response.create');
        return;
      }

      // If another response is in-flight, queue the tool result.
      if (window.__responseActive) {
        window.__pendingToolResults.push({ rawText, sourceHint });
        log('[INFO] response active — queued tool result');
        return;
      }

      let payloadObj = null;
      try { payloadObj = JSON.parse(rawText); } catch {}

      // Create strict instruction wrapper.
      const intro =
        'You just received JSON data from the tool "' + (sourceHint || 'unknown') + '". ' +
        'Use ONLY this data and the conversation so far. ' +
        'If ok:false or there is an error, explain it plainly and DO NOT guess or invent details.';

      const wrapped = payloadObj
        ? (intro + '\n\nJSON:\n' + JSON.stringify(payloadObj))
        : (intro + '\n\nNOTE: Tool returned non-JSON text:\n' + String(rawText).slice(0, 4000));

      try {
        window.__waitingForResponseId = true;
        setResponseActive(true);
        dc.send(JSON.stringify({
          type: 'response.create',
          response: { instructions: wrapped }
        }));
        log('[DC=>] response.create (tool output sent; source=' + (sourceHint || 'unknown') + ')');
      } catch (e) {
        log('[ERR] sendToolResultToModel send failed:', e?.message || e);
        setResponseActive(false);
        window.__waitingForResponseId = false;
      }
    }

    function flushPendingToolResults() {
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DC not open; cannot flush pending tool results');
        return;
      }
      if (window.__responseActive) {
        log('[INFO] still response active; will flush later');
        return;
      }
      const item = window.__pendingToolResults.shift();
      if (item) {
        log('[INFO] flushing queued tool result');
        sendToolResultToModel(item.rawText, item.sourceHint);
      }
    }

    // Text send (typed)
    sendBtn.addEventListener('click', () => {
      const text = (inputEl.value || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DataChannel not open yet; cannot send text.');
        return;
      }

      appendChat('user', text);

      try {
        // This is the "user prompt" path. (Not a tool result.)
        dc.send(JSON.stringify({ type: 'response.create', response: { instructions: text }}));
        log('[TX] text prompt → response.create');
      } catch (e) {
        log('[ERR] send text:', e?.message || e);
      }

      inputEl.value = '';
    });

    async function startRealtime() {
      try {
        setStatus('requesting mic…');

        try {
          if ('permissions' in navigator && navigator.permissions?.query) {
            const p = await navigator.permissions.query({ name: 'microphone' });
            log('[PERM] microphone:', p.state);
          }
        } catch {}

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mic = stream;
        const micTrack = mic.getTracks()[0];

        pc = new RTCPeerConnection();
        pc.oniceconnectionstatechange = () => log('ICE:', pc.iceConnectionState);
        pc.onconnectionstatechange = () => log('PC:', pc.connectionState);
        pc.ontrack = (e) => {
          log('[RT] ontrack: remote audio');
          audioEl.srcObject = e.streams[0];
          audioEl.play().catch(err => log('[AUDIO] play blocked:', err?.message || err));
        };

        const tx = pc.addTransceiver('audio', { direction: 'sendrecv' });
        try { await tx.sender.replaceTrack(micTrack); } catch {}
        if (tx.sender.setStreams) { try { tx.sender.setStreams(mic); } catch {} }

        dc = pc.createDataChannel('oai-events');

        // buffer of assistant text per response id
        const assistantTextBuffers = Object.create(null);

        dc.onopen = () => {
          log('[DC] open');
          setSendReady(true);
          setStatus('waiting-for-session');
        };

        dc.onmessage = (evt) => {
          let msg;
          try { msg = JSON.parse(evt.data); } catch { return; }

          log('[DC<=]', msg);

          // USER: recognized input text streamed back by the model
          if (msg.type === 'response.input_text.delta') {
            const deltaText =
              (msg.delta && typeof msg.delta.text === 'string')
                ? msg.delta.text
                : extractTextFromDelta(msg.delta);
            if (deltaText) appendChat('user', deltaText, true);
          }

          // Assistant transcript deltas
          if (msg.type === 'response.audio_transcript.delta') {
            const id = msg.response_id || 'default';
            const deltaText = extractTextFromDelta(msg.delta);
            if (deltaText) {
              assistantTextBuffers[id] = (assistantTextBuffers[id] || '') + deltaText;
              appendChat('assistant', deltaText, true);
            }
          }

          // Assistant text deltas (if present)
          if (msg.type === 'response.output_text.delta') {
            const id = msg.response_id || 'default';
            const deltaText = extractTextFromDelta(msg.delta);
            if (deltaText) {
              assistantTextBuffers[id] = (assistantTextBuffers[id] || '') + deltaText;
              appendChat('assistant', deltaText, true);
            }
          }

          if ((msg.type === 'response.completed' || msg.type === 'response.done') && msg.response_id) {
            delete assistantTextBuffers[msg.response_id];
          }

          if (msg.type === 'response.created' && msg.response && msg.response.id) {
            if (window.__waitingForResponseId) {
              window.__lastResponseCreatedId = msg.response.id;
              window.__waitingForResponseId = false;
              log('[INFO] captured response id', window.__lastResponseCreatedId);
            }
          }

          // clear the responseActive gate when the response completes
          const doneTypes = new Set([
            'response.done',
            'response.completed',
            'response.output_item.completed',
            'response.output_item.done'
          ]);

          if (doneTypes.has(msg.type) && msg.response_id) {
            if (!window.__lastResponseCreatedId || msg.response_id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response finished -> cleared __responseActive');
              flushPendingToolResults();
            }
          }

          if (msg.type === 'session.created') {
            const sessionUpdate = {
              type: 'session.update',
              session: {
                voice: 'alloy',
                turn_detection: {
                  type: 'server_vad',
                  threshold: 0.85,
                  prefix_padding_ms: 400,
                  silence_duration_ms: 1200,
                  idle_timeout_ms: 10000,
                  create_response: true,
                  // IMPORTANT: when you speak, the assistant should stop (prevents talking over you)
                  interrupt_response: true
                },
                instructions:
                  'Your name is Nyx. Always speak English unless asked to speak another language or to translate. ' 
                  
              }
            };

            try {
              dc.send(JSON.stringify(sessionUpdate));
              log('[DC=>] session.update sent');
            } catch (e) {
              log('[ERR] sending session.update', e?.message || e);
            }
            return;
          }

          if (msg.type === 'session.updated') {
            setStatus('ready');

            // Optional greeting — keep it normal.
            if (!window.__greeted) {
              window.__greeted = true;
              try {
                dc.send(JSON.stringify({
                  type: 'response.create',
                  response: { instructions: 'Say exactly: "Hi Rijk, nice tea cozy." ' +
                    'Use a conversational tone by default, but stay concise. ' +
                  'Never invent facts, actions, or tool results. If you are not sure, say you are not sure. ' +
                  'If Rijk asks about Gmail, Calendar, Google Drive, Docs, Sheets, or web search, you MUST call the appropriate tool first and base your answer ONLY on the tool result and what Rijk has said in this conversation. ' +
                  'If a tool returns ok:false or an error, explain it plainly and do not guess. ' +
                  'It is always better to say “I don’t know” / “I cannot access that” than to give a wrong answer. ' +
                  'You are a Phoenix Virtual Assistant designed for admin and business help. ' +
                  'Avoid adult content, terrorism, and gratuitous violence. ' +
                  'Do not claim you created calendar events/emails unless the tool result confirms it (ok:true and includes an id).' }
                }));
                log('[DC=>] response.create (greeting)');
              } catch (e) {
                log('[ERR] greeting send failed', e?.message || e);
              }
            }

            // Register tools AFTER instructions are applied
            if (!window.__toolsRegistered) {
              window.__toolsRegistered = true;
              window.toolArgBuf = Object.create(null);

              // Tool call handler (routes tool calls to your backend endpoints)
              window.handleToolCall = async function handleToolCall(name, args, callId) {
                try {
                  let url = '';
                  let body = {};

                  // ---- Docs ----
                  if (name === 'docs_read') {
                    url = '/api/workspace.js?action=docs.read';
                    body = {
                      docId: (args.docId || '').toString(),
                      docName: (args.docName || '').toString(),
                      folderName: (args.folderName || '').toString()
                    };
                  } else if (name === 'docs_createappend') {
                    url = '/api/workspace.js?action=docs.createappend';
                    body = {
                      docId: (args.docId || '').toString(),
                      docName: (args.docName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      mode: (args.mode || 'append').toString(),
                      text: (args.text ?? '').toString()
                    };

                  // ---- Drive ----
                  } else if (name === 'drive_search') {
                    url = '/api/workspace.js?action=drive.search';
                    body = {
                      name: (args.name || '').toString(),
                      mimeType: (args.mimeType || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      pageSize: args.pageSize || 25
                    };
                  } else if (name === 'drive_listroot') {
                    url = '/api/workspace.js?action=drive.listroot';
                    body = {};

                  // ---- Sheets ----
                  } else if (name === 'sheets_read') {
                    url = '/api/workspace.js?action=sheets.read';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || '').toString(),
                      range: (args.range || '').toString()
                    };
                  } else if (name === 'sheets_appendrow') {
                    url = '/api/workspace.js?action=sheets.appendrow';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || 'Sheet1').toString(),
                      values: Array.isArray(args.values) ? args.values : []
                    };
                  } else if (name === 'sheets_updatecell') {
                    url = '/api/workspace.js?action=sheets.updatecell';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || 'Sheet1').toString(),
                      cell: (args.cell || '').toString(),
                      value: args.value
                    };

                  // ---- Web ----
                  } else if (name === 'web_search') {
                    url = '/api/workspace.js?action=web.search';
                    body = {
                      query: (args.query || '').toString(),
                      num: args.num || 5,
                      site: (args.site || '').toString(),
                      freshnessDays: args.freshnessDays || 0
                    };

                  // ---- Gmail ----
                  } else if (name === 'gmail_list') {
                    url = '/api/workspace.js?action=gmail.list';
                    body = {
                      label: (args.label || 'INBOX').toString(),
                      maxResults: args.maxResults || 10
                    };
                  } else if (name === 'gmail_search') {
                    url = '/api/workspace.js?action=gmail.search';
                    body = {
                      q: (args.q || '').toString(),
                      maxResults: args.maxResults || 10
                    };
                  } else if (name === 'gmail_get') {
                    url = '/api/workspace.js?action=gmail.get';
                    body = { id: (args.id || '').toString() };

                  // ---- Calendar ----
                  } else if (name === 'calendar_list') {
                    url = '/api/workspace.js?action=calendar.list';
                    body = {
                      maxResults: args.maxResults || 10,
                      timeMin: (args.timeMin || '').toString(),
                      timeMax: (args.timeMax || '').toString()
                    };
                  } else if (name === 'calendar_create') {
                    url = '/api/workspace.js?action=calendar.create';
                    body = {
                      summary: (args.summary || '').toString(),
                      startIso: (args.startIso || '').toString(),
                      endIso: (args.endIso || '').toString(),
                      description: (args.description || '').toString(),
                      location: (args.location || '').toString()
                    };

                  } else {
                    const out = { ok: false, error: `Unsupported tool: ${name}` };
                    await sendToolResultToModel(JSON.stringify(out), name);
                    return;
                  }

                  // --------- THIS IS THE SECTION YOU SAID YOU COULDN'T FIND ----------
                  // It is inside: window.handleToolCall(...)
                  // It appears AFTER the big if/else tool router above, and BEFORE "const text = await r.text()"
                  const r = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(body)
                  });
                  // -------------------------------------------------------------------

                  const text = await r.text();
                  log('[TOOL]', name, r.status, text.slice(0, 400));

                  // Pass raw tool output back to the model; wrapper enforces "no guessing"
                  await sendToolResultToModel(text, name);
                } catch (e) {
                  const out = { ok: false, error: String(e?.message || e) };
                  await sendToolResultToModel(JSON.stringify(out), name);
                }
              };

              const toolsUpdate = {
                type: 'session.update',
                session: {
                  tool_choice: 'auto',
                  tools: [
                    {
                      type: 'function',
                      name: 'docs_read',
                      description: 'Read a Google Doc by name (optional folderName). Returns contents.',
                      parameters: {
                        type: 'object',
                        properties: {
                          docId: { type: 'string', description: 'Optional Google Doc ID (preferred if known)' },
                          docName: { type: 'string', description: 'Document name to read' },
                          folderName: { type: 'string', description: 'Optional parent folder; omit for root' }
                        },
                        required: ['docName']
                      }
                    },
                    {
                      type: 'function',
                      name: 'docs_createappend',
                      description: 'Create a Doc (or open existing) then append or replace text. Uses backend for actual write.',
                      parameters: {
                        type: 'object',
                        properties: {
                          docId: { type: 'string', description: 'Optional Google Doc ID' },
                          docName: { type: 'string', description: 'Target document name' },
                          folderName: { type: 'string', description: 'Optional parent folder; omit for root' },
                          mode: { type: 'string', enum: ['append','replace'], description: 'append (default) or replace' },
                          text: { type: 'string', description: 'Text to write' }
                        },
                        required: ['text']
                      }
                    },
                    {
                      type: 'function',
                      name: 'drive_search',
                      description: 'Search Google Drive for files/folders by name, mimeType, and optional folder.',
                      parameters: {
                        type: 'object',
                        properties: {
                          name: { type: 'string', description: 'Name fragment to search for' },
                          mimeType: { type: 'string', description: 'Optional mimeType filter' },
                          folderName: { type: 'string', description: 'Optional parent folder name' },
                          pageSize: { type: 'integer', description: 'Max results (1-200)', minimum: 1, maximum: 200 }
                        },
                        required: []
                      }
                    },
                    {
                      type: 'function',
                      name: 'drive_listroot',
                      description: 'List files in the root of My Drive.',
                      parameters: { type: 'object', properties: {}, required: [] }
                    },
                    {
                      type: 'function',
                      name: 'sheets_read',
                      description: 'Read a Sheet range given fileName, optional folderName, tab and range.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          range: { type: 'string', description: 'A1 range, e.g. A:Z or B2:G50' }
                        },
                        required: ['fileName']
                      }
                    },
                    {
                      type: 'function',
                      name: 'sheets_appendrow',
                      description: 'Append a row of values to a Sheet.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          values: { type: 'array', items: { type: 'string' }, description: 'Row values as array' }
                        },
                        required: ['fileName','values']
                      }
                    },
                    {
                      type: 'function',
                      name: 'sheets_updatecell',
                      description: 'Update a single cell in a Sheet.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          cell: { type: 'string', description: 'A1 cell reference, e.g. B7' },
                          value: { description: 'Value to write (any JSON type)' }
                        },
                        required: ['fileName','cell']
                      }
                    },
                    {
                      type: 'function',
                      name: 'web_search',
                      description: 'Perform a web search via SerpAPI and return summarized results.',
                      parameters: {
                        type: 'object',
                        properties: {
                          query: { type: 'string', description: 'Search query' },
                          num: { type: 'integer', description: 'Number of results (1-10)', minimum: 1, maximum: 10 },
                          site: { type: 'string', description: 'Optional site: filter, e.g. example.com' },
                          freshnessDays: { type: 'integer', description: 'Optional freshness limit in days', minimum: 0, maximum: 365 }
                        },
                        required: ['query']
                      }
                    },

                    // Gmail (readonly)
                    {
                      type: 'function',
                      name: 'gmail_list',
                      description: 'List recent Gmail messages (metadata).',
                      parameters: {
                        type: 'object',
                        properties: {
                          label: { type: 'string', description: 'Gmail label; default INBOX' },
                          maxResults: { type: 'integer', description: 'Max messages (1–20)', minimum: 1, maximum: 20 }
                        },
                        required: []
                      }
                    },
                    {
                      type: 'function',
                      name: 'gmail_search',
                      description: 'Search Gmail history by query string (Gmail search syntax). Returns message IDs.',
                      parameters: {
                        type: 'object',
                        properties: {
                          q: { type: 'string', description: 'Gmail search query, e.g. from:someone subject:(quote) newer_than:30d' },
                          maxResults: { type: 'integer', description: 'Max IDs (1–20)', minimum: 1, maximum: 20 }
                        },
                        required: ['q']
                      }
                    },
                    {
                      type: 'function',
                      name: 'gmail_get',
                      description: 'Get a Gmail message by ID and return plain-text body for reading aloud.',
                      parameters: {
                        type: 'object',
                        properties: { id: { type: 'string', description: 'Gmail message ID' } },
                        required: ['id']
                      }
                    },

                    // Calendar
                    {
                      type: 'function',
                      name: 'calendar_list',
                      description: 'Read upcoming events from the primary Google Calendar (readonly).',
                      parameters: {
                        type: 'object',
                        properties: {
                          maxResults: { type: 'integer', description: 'Max events (1–20)', minimum: 1, maximum: 20 },
                          timeMin: { type: 'string', description: 'Optional ISO timeMin; default now' },
                          timeMax: { type: 'string', description: 'Optional ISO timeMax; default ~7 days from now' }
                        },
                        required: []
                      }
                    },
                    {
                      type: 'function',
                      name: 'calendar_create',
                      description: 'Create a calendar event. Must only claim success if ok:true and eventId returned.',
                      parameters: {
                        type: 'object',
                        properties: {
                          summary: { type: 'string', description: 'Event title' },
                          startIso: { type: 'string', description: 'Start time ISO string' },
                          endIso: { type: 'string', description: 'End time ISO string' },
                          description: { type: 'string', description: 'Optional description' },
                          location: { type: 'string', description: 'Optional location' }
                        },
                        required: ['summary','startIso','endIso']
                      }
                    }
                  ]
                }
              };

              try {
                dc.send(JSON.stringify(toolsUpdate));
                log('[DC=>] tools session.update sent');
              } catch (e) {
                log('[ERR] sending tools session.update', e?.message || e);
              }
            }
            return;
          }

          // Tool arguments streaming (accumulate JSON arguments then execute)
          {
            const t = msg.type;

            const isDelta =
              t === 'response.function_call_arguments.delta' ||
              t === 'response.function_call.arguments.delta' ||
              t === 'response.tool_call.delta' ||
              t === 'response.tool_call.arguments.delta';

            const isDone =
              t === 'response.function_call_arguments.done' ||
              t === 'response.function_call.completed' ||
              t === 'response.tool_call.completed' ||
              t === 'response.tool_call.arguments.done';

            if ((isDelta || isDone) && !window.__toolsRegistered) return;

            if (isDelta) {
              const id = msg.call_id || msg.id;
              const frag =
                (typeof msg.delta === 'string' ? msg.delta :
                 typeof msg.arguments === 'string' ? msg.arguments : '');
              window.toolArgBuf = window.toolArgBuf || Object.create(null);
              window.toolArgBuf[id] = (window.toolArgBuf[id] || '') + frag;
              return;
            }

            if (isDone) {
              const id = msg.call_id || msg.id;
              const name = msg.name || msg.tool_name;
              const argsStr =
                (typeof msg.arguments === 'string'
                  ? msg.arguments
                  : (window.toolArgBuf ? window.toolArgBuf[id] : '')
                ) || '{}';

              if (window.toolArgBuf) delete window.toolArgBuf[id];

              let args = {};
              try { args = JSON.parse(argsStr); } catch { args = {}; }

              if (typeof window.handleToolCall === 'function') {
                window.handleToolCall(name, args, id);
              }
              return;
            }
          }

          if (msg.type === 'error') {
            console.error('[Realtime ERROR]', msg.error || msg);
            setStatus('error');
            return;
          }
        };

        dc.onerror = (e) => log('[DC] error', e);
        dc.onclose = () => { log('[DC] closed'); setSendReady(false); setStatus('disconnected'); };

        setStatus('creating offer…');
        const offer = await pc.createOffer({ offerToReceiveAudio: 1 });
        await pc.setLocalDescription(offer);

        const res = await fetch('/api/realtime/offer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp' },
          body: offer.sdp,
          credentials: 'include'
        });

        const answer = await res.text();
        log('[HTTP] /api/realtime/offer →', res.status);

        if (!res.ok) {
          try { log('[ERR]', JSON.parse(answer)); } catch { log('[ERR]', answer); }
          throw new Error('Offer→Answer failed');
        }

        await pc.setRemoteDescription({ type: 'answer', sdp: answer });
        setStatus('connected — waiting for channel…');
        log('[RT] connected; speak to the assistant…');
      } catch (e) {
        setStatus('error');
        log('[EXC] startRealtime:', e?.message || e);
        throw e;
      }
    }

    function stopRealtime() {
      try { pc?.getSenders().forEach(s => s.track?.stop()); pc?.close(); } catch {}
      try { mic?.getTracks().forEach(t => t.stop()); } catch {}
      pc = null; mic = null; dc = null; audioEl.srcObject = null;
      setSendReady(false);
      setStatus('idle');

      window.__responseActive = false;
      window.__waitingForResponseId = false;
      window.__lastResponseCreatedId = null;
      window.__pendingToolResults = [];

      log('[RT] stopped');
    }

    async function ensureGoogleAuth() {
      try {
        const r = await fetch('/api/google.js?op=status', { credentials: 'include' });
        const data = await r.json();
        log('[AUTH]', data);
        if (data.connected && !data.refresh_problem) return true;

        setStatus('connecting Google…');
        window.location.href = '/api/google.js?op=start';
        return false;
      } catch (e) {
        log('[AUTH] status error:', e?.message || e);
        window.location.href = '/api/google.js?op=start';
        return false;
      }
    }

    btn.addEventListener('click', async () => {
      btn.disabled = true;
      try {
        if (!live) {
          btnLabel.textContent = 'Connecting…';
          const ok = await ensureGoogleAuth();
          if (!ok) return;
          await startRealtime();
          live = true;
          btnLabel.textContent = 'Stop';
        } else {
          stopRealtime();
          live = false;
          btnLabel.textContent = 'Start';
        }
      } catch {
        stopRealtime();
        live = false;
        btnLabel.textContent = 'Start';
      } finally {
        btn.disabled = false;
      }
    });

    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); if (!sendBtn.disabled) sendBtn.click(); }
    });
  </script>
</body>
</html>
