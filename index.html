<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phoenix VA — Realtime</title>
  <meta name="color-scheme" content="light dark" />
  <style>
    :root {
      --navy: #0B1B34;
      --card: #0F223F;
      --text: #E8EEF9;
      --muted: #9FB1D1;
      --accent: #FFFFFF;
      --btn-bg: #001F3F;
      --btn-tx: #FFFFFF;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      background: var(--navy);
      color: var(--text);
      display: grid;
      place-items: center;
      min-height: 100svh;
    }
    .wrap { width: 100%; max-width: 720px; padding: 20px; display: grid; gap: 16px; }
    .brand { display: grid; place-items: center; gap: 10px; text-align: center; }
    .brand img {
      width: 96px; height: auto; display: block;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,.25));
      user-select: none;
    }
    .brand h1 { margin: 0; font-size: 18px; font-weight: 600; color: var(--muted); letter-spacing: .3px; }
    .card {
      background: color-mix(in oklab, var(--card) 90%, black 10%);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, .btn {
      appearance: none; border: none; background: #F4F6FC; color: #0B1B34;
      padding: 10px 14px; border-radius: 12px; font-weight: 700; cursor: pointer;
      transition: transform .04s ease, opacity .2s ease, background .2s ease;
    }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #voiceToggle {
      background: var(--btn-bg); color: var(--btn-tx);
      display: inline-flex; align-items: center; gap: 10px;
      padding: 12px 18px; border-radius: 16px;
    }
    #voiceToggle img { width: 28px; height: 28px; object-fit: contain; display: block; pointer-events: none; user-select: none; }
    #voiceToggle:hover { background: #003366; }
    .btn-outline { background: transparent; color: var(--accent); border: 1px solid rgba(255,255,255,.2); }
    input[type="text"] {
      flex: 1 1 220px; background: rgba(255,255,255,.06); color: var(--text);
      border: 1px solid rgba(255,255,255,.15); border-radius: 10px; padding: 10px 12px; outline: none;
    }
    input::placeholder { color: rgba(255,255,255,.5); }
    #log {
      white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px; line-height: 1.4; color: #CFE2FF; max-height: 280px; overflow: auto;
      background: rgba(0,0,0,.25); border-radius: 10px; padding: 12px; border: 1px solid rgba(255,255,255,.08);
    }
    .hint { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="brand">
      <img src="/public/logo.png" alt="Phoenix VA Logo" />
      <h1>Phoenix VA — Realtime</h1>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <button id="voiceToggle">
            <img src="/public/logo.png" alt="Phoenix VA Logo" width="56" height="56" />
            <span id="voiceLabel">Start</span>
          </button>

          <button id="googleConnect" class="btn-outline" title="Connect Google">Connect Google</button>
        </div>
        <span class="hint" id="status">idle</span>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="textInput" type="text" placeholder="Ask me anything">
        <button id="sendText">Send</button>
      </div>

      <audio id="assistantAudio" autoplay playsinline style="display:none"></audio>
      <div id="log" style="margin-top:12px"></div>
    </div>
  </div>

  <script type="module">
    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const btn = document.getElementById('voiceToggle');
    const btnLabel = document.getElementById('voiceLabel');
    const btnGoogle = document.getElementById('googleConnect');
    const inputEl = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendText');
    const setSendReady = (ready) => { sendBtn.disabled = !ready; };
    setSendReady(false);

    const audioEl = document.getElementById('assistantAudio');

    const log = (...a) => {
      const s = a.map(x => typeof x === 'string' ? x : JSON.stringify(x, null, 2)).join(' ');
      logEl.textContent += s + '\n';
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...a);
    };
    const setStatus = (s) => { statusEl.textContent = s; };

    let pc = null, mic = null, dc = null, live = false;

    const toolArgBuf = Object.create(null);

    async function handleToolCall(name, args, callId) {
      try {
        let url = '', body = {};

        if (name === 'sheets.read') {
          url = '/api/workspace.js?action=sheets.read';
          body = {
            fileName: args.fileName || '',
            folderName: args.folderName || '',
            tab: args.tab || 'Sheet1',
            range: args.range || 'A:Z'
          };
        } else if (name === 'sheets.updatecell') {
          url = '/api/workspace.js?action=sheets.updatecell';
          body = {
            fileName: args.fileName || '',
            folderName: args.folderName || '',
            tab: args.tab || 'Sheet1',
            cell: args.cell || '',
            value: args.value
          };
        } else if (name === 'drive.search') {
          url = '/api/workspace.js?action=drive.search';
          body = {
            mimeType: args.mimeType || '',
            name: args.name || '',
            folderName: args.folderName || '',
            pageSize: Math.max(1, Math.min(Number(args.pageSize || 50), 200))
          };
        } else if (name === 'docs.read') {
          url = '/api/workspace.js?action=docs.read';
          body = {
            docName: args.docName || '',
            folderName: args.folderName || ''
          };
        } else {
          const out = { error: `Unsupported tool: ${name}` };
          dc.send(JSON.stringify({ type: 'tool.output', tool_call_id: callId, output: JSON.stringify(out) }));
          dc.send(JSON.stringify({ type: 'response.create' }));
          return;
        }

        const r = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(body)
        });
        const text = await r.text();
        log('[TOOL]', name, r.status, text.slice(0, 300));

        dc.send(JSON.stringify({ type: 'tool.output', tool_call_id: callId, output: text }));
        dc.send(JSON.stringify({ type: 'response.create' }));
      } catch (e) {
        const out = { error: String(e?.message || e) };
        dc.send(JSON.stringify({ type: 'tool.output', tool_call_id: callId, output: JSON.stringify(out) }));
        dc.send(JSON.stringify({ type: 'response.create' }));
      }
    }

    btnGoogle.addEventListener('click', () => {
      window.location.href = '/api/google.js?op=start';
    });

    sendBtn.addEventListener('click', () => {
      const text = (inputEl.value || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DataChannel not open yet; cannot send text.');
        return;
      }
      try {
        dc.send(JSON.stringify({ type: 'response.create', response: { instructions: text }}));
        log('[TX] text prompt → response.create');
      } catch (e) {
        log('[ERR] send text:', e?.message || e);
      }
    });

    async function startRealtime() {
      try {
        setStatus('requesting mic…');
        try {
          if ('permissions' in navigator && navigator.permissions?.query) {
            const p = await navigator.permissions.query({ name: 'microphone' });
            log('[PERM] microphone:', p.state);
          }
        } catch {}

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mic = stream;
        const micTrack = mic.getTracks()[0];

        pc = new RTCPeerConnection();
        pc.oniceconnectionstatechange = () => log('ICE:', pc.iceConnectionState);
        pc.onconnectionstatechange = () => log('PC:', pc.connectionState);
        pc.ontrack = (e) => {
          log('[RT] ontrack: remote audio');
          audioEl.srcObject = e.streams[0];
          audioEl.play().catch(err => log('[AUDIO] play blocked:', err?.message || err));
        };

        const tx = pc.addTransceiver('audio', { direction: 'sendrecv' });
        try { await tx.sender.replaceTrack(micTrack); } catch {}
        if (tx.sender.setStreams) { try { tx.sender.setStreams(mic); } catch {} }

        dc = pc.createDataChannel('oai-events');

        dc.onopen = () => {
          log('[DC] open');
          setSendReady(true);
          setStatus('ready');
          try {
            const sessionUpdate = {
              type: 'session.update',
              session: {
                voice: 'cedar',
                instructions:
                  'Your name is Nyx. Always start speaking English. Be friendly and helpful. ' +
                  'Never discuss adult content, sexuality, terrorism or violence.' +
                  'When the user asks about Google Drive, Google Docs, or Google Sheets, you MUST call the tools and wait for their results. ' +
                  'For a request like "list my folders", call drive.search with no folderName. ' +
                  'Never guess or describe file contents without a successful tool call. ' +
                  'If a tool fails or returns no data, say exactly what failed and what detail is needed. ' +
                  'When you read a sheet, state the exact file name, tab, and range you used. ' +
                  'When you edit a cell, state the file name, tab, and cell you modified. ' +
                  'Prefer tools over free-text answers for anything involving Drive/Docs/Sheets.',
                tools: [
                  {
                    type: 'function',
                    name: 'sheets.read',
                    description: 'Read rows from a Google Sheet by name and optional folderName, tab, range.',
                    parameters: {
                      type: 'object',
                      properties: {
                        fileName: { type: 'string', description: 'Exact sheet name' },
                        folderName: { type: 'string', description: 'Optional parent folder name' },
                        tab: { type: 'string', description: 'Sheet tab (default Sheet1)' },
                        range: { type: 'string', description: 'A1 range, e.g. A:Z or A2:E50' }
                      },
                      required: ['fileName']
                    }
                  },
                  {
                    type: 'function',
                    name: 'sheets.updatecell',
                    description: 'Update a single cell in a Google Sheet.',
                    parameters: {
                      type: 'object',
                      properties: {
                        fileName: { type: 'string' },
                        folderName: { type: 'string' },
                        tab: { type: 'string', description: 'Default Sheet1' },
                        cell: { type: 'string', description: 'A1 notation, e.g. B7' },
                        value: {}
                      },
                      required: ['fileName', 'cell', 'value']
                    }
                  },
                  {
                    type: 'function',
                    name: 'drive.search',
                    description: 'Search Google Drive for files or folders. Use with no arguments to list top-level folders.',
                    parameters: {
                      type: 'object',
                      properties: {
                        mimeType: { type: 'string', description: 'Use application/vnd.google-apps.folder to list folders' },
                        name: { type: 'string', description: 'Optional partial file/folder name' },
                        folderName: { type: 'string', description: 'Optional parent folder name' },
                        pageSize: { type: 'integer', minimum: 1, maximum: 200 }
                      }
                    }
                  },
                  {
                    type: 'function',
                    name: 'docs.read',
                    description: 'Read plain text from a Google Doc by name (optional folderName).',
                    parameters: {
                      type: 'object',
                      properties: {
                        docName: { type: 'string' },
                        folderName: { type: 'string' }
                      },
                      required: ['docName']
                    }
                  }
                ]
              }
            };
            dc.send(JSON.stringify(sessionUpdate));
            dc.send(JSON.stringify({ type: 'response.create', response: { instructions: 'Hello! Nyx is ready with Google Drive tools.' } }));
          } catch (e) { log('[DC] session.update error:', e?.message || e); }
        };

        dc.onmessage = (evt) => {
          log('[DC msg raw]', evt.data);
          let msg;
          try { msg = JSON.parse(evt.data); }
          catch { log('[EVT raw]', evt.data?.slice?.(0, 400) || evt.data); return; }

          const isDelta =
            msg.type === 'response.function_call_arguments.delta' ||
            msg.type === 'response.function_call.arguments.delta';

          const isDone =
            msg.type === 'response.function_call_arguments.done' ||
            msg.type === 'response.function_call.completed';

          if (isDelta) {
            const id = msg.call_id || msg.id;
            const frag =
              (typeof msg.delta === 'string' ? msg.delta :
              (typeof msg.arguments === 'string' ? msg.arguments : ''));
            toolArgBuf[id] = (toolArgBuf[id] || '') + frag;
            return;
          }

          if (isDone) {
            const id = msg.call_id || msg.id;
            const name = msg.name;
            const argsStr =
              (typeof msg.arguments === 'string' ? msg.arguments : toolArgBuf[id]) || '{}';
            delete toolArgBuf[id];

            let args = {};
            try { args = JSON.parse(argsStr); } catch {}
            handleToolCall(name, args, id);
            return;
          }
        };

        dc.onerror = (e) => log('[DC] error', e);
        dc.onclose = () => { log('[DC] closed'); setSendReady(false); setStatus('disconnected'); };

        setStatus('creating offer…');
        const offer = await pc.createOffer({ offerToReceiveAudio: 1 });
        await pc.setLocalDescription(offer);

        const res = await fetch('/api/realtime/offer.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp' },
          body: offer.sdp,
          credentials: 'include'
        });
        const answer = await res.text();
        log('[HTTP] /api/realtime/offer →', res.status);
        if (!res.ok) { try { log('[ERR]', JSON.parse(answer)); } catch { log('[ERR]', answer); } throw new Error('Offer→Answer failed'); }

        await pc.setRemoteDescription({ type: 'answer', sdp: answer });
        setStatus('connected — waiting for channel…');
        log('[RT] connected; speak to the assistant…');
      } catch (e) {
        setStatus('error');
        log('[EXC] startRealtime:', e?.message || e);
        throw e;
      }
    }

    function stopRealtime() {
      try { pc?.getSenders().forEach(s => s.track?.stop()); pc?.close(); } catch {}
      try { mic?.getTracks().forEach(t => t.stop()); } catch {}
      pc = null; mic = null; dc = null; audioEl.srcObject = null;
      setSendReady(false);
      setStatus('idle');
      log('[RT] stopped');
    }

    async function ensureGoogleAuth() {
      try {
        const r = await fetch('/api/google.js?op=status', { credentials: 'include' });
        const data = await r.json();
        log('[AUTH]', data);
        if (data.connected && !data.refresh_problem) return true;
        setStatus('connecting Google…');
        window.location.href = '/api/google.js?op=start';
        return false;
      } catch (e) {
        log('[AUTH] status error:', e?.message || e);
        window.location.href = '/api/google.js?op=start';
        return false;
      }
    }

    btn.addEventListener('click', async () => {
      btn.disabled = true;
      try {
        if (!live) {
          btnLabel.textContent = 'Connecting…';
          const ok = await ensureGoogleAuth();
          if (!ok) return;
          await startRealtime();
          live = true;
          btnLabel.textContent = 'Stop';
        } else {
          stopRealtime();
          live = false;
          btnLabel.textContent = 'Start';
        }
      } catch {
        stopRealtime();
        live = false;
        btnLabel.textContent = 'Start';
      } finally {
        btn.disabled = false;
      }
    });

    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); if (!sendBtn.disabled) sendBtn.click(); }
    });
  </script>
</body>
</html>
