<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phoenix VA — Realtime</title>
  <meta name="color-scheme" content="light dark" />
  <style>
    :root {
      --navy: #0B1B34;
      --card: #0F223F;
      --text: #E8EEF9;
      --muted: #9FB1D1;
      --accent: #FFFFFF;
      --btn-bg: #001F3F;
      --btn-tx: #FFFFFF;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      background: var(--navy);
      color: var(--text);
      display: grid;
      place-items: center;
      min-height: 100svh;
    }
    .wrap { width: 100%; max-width: 720px; padding: 20px; display: grid; gap: 16px; }
    .brand { display: grid; place-items: center; gap: 10px; text-align: center; }
    .brand img {
      width: 96px; height: auto; display: block;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,.25));
      user-select: none;
    }
    .brand h1 { margin: 0; font-size: 18px; font-weight: 600; color: var(--muted); letter-spacing: .3px; }
    .card {
      background: color-mix(in oklab, var(--card) 90%, black 10%);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button, .btn {
      appearance: none; border: none; background: #F4F6FC; color: #0B1B34;
      padding: 10px 14px; border-radius: 12px; font-weight: 700; cursor: pointer;
      transition: transform .04s ease, opacity .2s ease, background .2s ease;
    }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #voiceToggle {
      background: var(--btn-bg); color: var(--btn-tx);
      display: inline-flex; align-items: center; gap: 10px;
      padding: 12px 18px; border-radius: 16px;
    }
    #voiceToggle:hover { background: #003366; }
    .btn-outline { background: transparent; color: var(--accent); border: 1px solid rgba(255,255,255,.2); }
    input[type="text"] {
      flex: 1 1 220px; background: rgba(255,255,255,.06); color: var(--text);
      border: 1px solid rgba(255,255,255,.15); border-radius: 10px; padding: 10px 12px; outline: none;
    }
    input::placeholder { color: rgba(255,255,255,.5); }

    /* Tabs + panels */
    .tabs {
      display: flex;
      gap: 4px;
      margin-top: 12px;
      margin-bottom: 4px;
    }
    .tab-btn {
      flex: 0 0 auto;
      border-radius: 12px 12px 0 0;
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      border: 1px solid transparent;
      cursor: pointer;
    }
    .tab-btn.active {
      background: rgba(0,0,0,0.3);
      color: var(--accent);
      border-color: rgba(255,255,255,0.15);
      border-bottom-color: transparent;
    }
    .panel {
      border-radius: 0 10px 10px 10px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.25);
      padding: 10px 12px;
      overflow: auto;
      display: none;
    }
    .panel.active { display: block; }

    /* Conversation panel behaviour */
    #chat {
      font-size: 13px;
      line-height: 1.4;
      max-height: 80px;           /* collapsed height */
      overflow: auto;
      transition: max-height 0.2s ease;
    }
    #chat.expanded {
      max-height: 70vh;           /* expanded height */
    }

    .msg {
      margin-bottom: 6px;
    }
    .msg span.role {
      font-weight: 600;
      margin-right: 4px;
      color: var(--muted);
    }

    #log {
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px; line-height: 1.4; color: #CFE2FF;
      max-height: 280px;
      overflow: auto;
    }
    .hint { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="brand">
      <img src="/public/logo.png" alt="Phoenix VA Logo" />
      <h1>Phoenix VA</h1>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <button id="voiceToggle">
            <span id="voiceLabel">Start</span>
          </button>
        </div>
        <span class="hint" id="status">idle</span>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="textInput" type="text" placeholder="Ask me anything">
        <button id="sendText">Send</button>
      </div>

      <audio id="assistantAudio" autoplay playsinline style="display:none"></audio>

      <!-- Tabs + panels -->
      <div class="tabs">
        <button class="tab-btn active" data-tab="chat">Conversation</button>
        <button class="tab-btn" data-tab="log">Logs</button>
      </div>
      <div id="chat" class="panel active"></div>
      <div id="log" class="panel"></div>
    </div>
  </div>

  <script type="module">
    const logEl = document.getElementById('log');
    const chatEl = document.getElementById('chat');
    const statusEl = document.getElementById('status');
    const btn = document.getElementById('voiceToggle');
    const btnLabel = document.getElementById('voiceLabel');
    const inputEl = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendText');
    const audioEl = document.getElementById('assistantAudio');

    const setSendReady = (ready) => { sendBtn.disabled = !ready; };
    setSendReady(false);

    // Click to expand / collapse the conversation panel
    if (chatEl) {
      chatEl.addEventListener('click', () => {
        chatEl.classList.toggle('expanded');
      });
    }

    // Conversation helpers
    function appendChat(role, text, replaceLastForRole = false) {
      if (!text) return;
      if (replaceLastForRole) {
        for (let i = chatEl.children.length - 1; i >= 0; i--) {
          const node = chatEl.children[i];
          if (node.dataset && node.dataset.role === role) {
            const spanText = node.querySelector('.content');
            if (spanText) {
              spanText.textContent += text;
              chatEl.scrollTop = chatEl.scrollHeight;
              return;
            }
          }
        }
      }
      const div = document.createElement('div');
      div.className = 'msg';
      div.dataset.role = role;
      const label = document.createElement('span');
      label.className = 'role';
      label.textContent = role === 'user' ? 'Rijk:' : 'Nyx:';
      const content = document.createElement('span');
      content.className = 'content';
      content.textContent = text;
      div.appendChild(label);
      div.appendChild(content);
      chatEl.appendChild(div);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // Tabs
    document.querySelectorAll('.tab-btn').forEach(btnTab => {
      btnTab.addEventListener('click', () => {
        const tab = btnTab.dataset.tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b === btnTab));
        document.querySelectorAll('.panel').forEach(p => {
          p.classList.toggle('active', p.id === tab);
        });
      });
    });

    const log = (...a) => {
      const s = a.map(x => typeof x === 'string' ? x : JSON.stringify(x, null, 2)).join(' ');
      logEl.textContent += s + '\n';
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...a);
    };
    const setStatus = (s) => { statusEl.textContent = s; };

    let pc = null, mic = null, dc = null, live = false;

    // Response state management
    window.__responseActive = false;
    window.__waitingForResponseId = false;
    window.__lastResponseCreatedId = null;
    window.__pendingToolResults = [];

    const RESPONSE_ACTIVE_FALLBACK_MS = 12000;
    let __responseActiveFallbackTimer = null;
    function setResponseActive(active) {
      window.__responseActive = !!active;
      if (active) {
        clearTimeout(__responseActiveFallbackTimer);
        __responseActiveFallbackTimer = setTimeout(() => {
          if (window.__responseActive) {
            log('[WARN] responseActive fallback fired; clearing flag');
            window.__responseActive = false;
            window.__waitingForResponseId = false;
            window.__lastResponseCreatedId = null;
            flushPendingToolResults();
          }
        }, RESPONSE_ACTIVE_FALLBACK_MS);
      } else {
        clearTimeout(__responseActiveFallbackTimer);
        __responseActiveFallbackTimer = null;
      }
    }

    async function sendResponseInstructions(text) {
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DC not open; cannot send response.create');
        return;
      }
      if (window.__responseActive) {
        window.__pendingToolResults.push({ text });
        log('[INFO] response active — queued tool result');
        return;
      }
      try {
        window.__waitingForResponseId = true;
        setResponseActive(true);
        dc.send(JSON.stringify({
          type: 'response.create',
          response: { instructions: text }
        }));
        log('[DC=>] response.create (tool output sent)');
      } catch (e) {
        log('[ERR] sendResponseInstructions send failed:', e?.message || e);
        setResponseActive(false);
        window.__waitingForResponseId = false;
      }
    }

    function flushPendingToolResults() {
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DC not open; cannot flush pending tool results');
        return;
      }
      if (window.__responseActive) {
        log('[INFO] still response active; will flush later');
        return;
      }
      const item = window.__pendingToolResults.shift();
      if (item) {
        log('[INFO] flushing queued tool result');
        sendResponseInstructions(item.text);
      }
    }

    sendBtn.addEventListener('click', () => {
      const text = (inputEl.value || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open') {
        log('[WARN] DataChannel not open yet; cannot send text.');
        return;
      }
      appendChat('user', text);
      try {
        dc.send(JSON.stringify({ type: 'response.create', response: { instructions: text }}));
        log('[TX] text prompt → response.create');
      } catch (e) {
        log('[ERR] send text:', e?.message || e);
      }
      inputEl.value = '';
    });

    async function startRealtime() {
      try {
        setStatus('requesting mic…');
        try {
          if ('permissions' in navigator && navigator.permissions?.query) {
            const p = await navigator.permissions.query({ name: 'microphone' });
            log('[PERM] microphone:', p.state);
          }
        } catch (e) {}

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mic = stream;
        const micTrack = mic.getTracks()[0];

        pc = new RTCPeerConnection();
        pc.oniceconnectionstatechange = () => log('ICE:', pc.iceConnectionState);
        pc.onconnectionstatechange = () => log('PC:', pc.connectionState);
        pc.ontrack = (e) => {
          log('[RT] ontrack: remote audio');
          audioEl.srcObject = e.streams[0];
          audioEl.play().catch(err => log('[AUDIO] play blocked:', err?.message || err));
        };

        const tx = pc.addTransceiver('audio', { direction: 'sendrecv' });
        try { await tx.sender.replaceTrack(micTrack); } catch {}
        if (tx.sender.setStreams) { try { tx.sender.setStreams(mic); } catch {} }

        dc = pc.createDataChannel('oai-events');

        let sessionIsCreated = false;
        let sessionIsUpdated = false;

        // buffer of assistant text per response id
        const assistantTextBuffers = Object.create(null);
        const assistantHadStreaming = Object.create(null);

        dc.onopen = () => {
          log('[DC] open');
          setSendReady(true);
          setStatus('waiting-for-session');
        };

        dc.onmessage = (evt) => {
          let msg;
          try { msg = JSON.parse(evt.data); } catch (e) { return; }

          log('[DC<=]', msg);

          // Live transcript of your speech as "Rijk:"
          if (msg.type === 'input_text.delta') {
            let delta = '';
            if (typeof msg.delta === 'string') {
              delta = msg.delta;
            } else if (msg.delta && typeof msg.delta.text === 'string') {
              delta = msg.delta.text;
            }
            if (delta) {
              appendChat('user', delta, true);
            }
            return;
          }

          // Assistant text output (streaming, if available)
          if (msg.type && msg.type.indexOf('response.output_text') === 0) {
            const id = msg.response_id || 'default';

            let deltaText = '';
            if (typeof msg.delta === 'string') {
              deltaText = msg.delta;
            } else if (msg.delta && typeof msg.delta.text === 'string') {
              deltaText = msg.delta.text;
            }

            if (!deltaText) {
              if (typeof msg.output_text === 'string') {
                deltaText = msg.output_text;
              } else if (msg.output_text && typeof msg.output_text.text === 'string') {
                deltaText = msg.output_text.text;
              }
            }

            if (!deltaText) return;

            assistantHadStreaming[id] = true;
            assistantTextBuffers[id] = (assistantTextBuffers[id] || '') + deltaText;
            appendChat('assistant', deltaText, true);
          }

          if (msg.type === 'response.created' && msg.response && msg.response.id) {
            if (window.__waitingForResponseId) {
              window.__lastResponseCreatedId = msg.response.id;
              window.__waitingForResponseId = false;
              log('[INFO] captured response id', window.__lastResponseCreatedId);
            }
          }

          if (msg.type === 'response.done' && msg.response_id) {
            const id = msg.response_id;
            delete assistantTextBuffers[id];
            delete assistantHadStreaming[id];

            if (!window.__lastResponseCreatedId || id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.done -> cleared __responseActive');
              flushPendingToolResults();
            }
          }

          if (msg.type === 'response.completed' && msg.response_id) {
            const id = msg.response_id;

            // Fallback: if there was no streaming text, try to extract final text
            if (!assistantHadStreaming[id]) {
              let fullText = assistantTextBuffers[id] || '';

              if (!fullText) {
                const resp = msg.response || msg;
                const outputs = resp.output || resp.outputs || [];
                if (Array.isArray(outputs)) {
                  for (const o of outputs) {
                    const contentArr = o.content || [];
                    if (!Array.isArray(contentArr)) continue;
                    for (const c of contentArr) {
                      if (!c) continue;
                      if (c.type === 'output_text' && c.output_text && typeof c.output_text.text === 'string') {
                        fullText += c.output_text.text;
                      } else if (typeof c.text === 'string') {
                        fullText += c.text;
                      } else if (c.output_text && Array.isArray(c.output_text)) {
                        for (const ot of c.output_text) {
                          if (typeof ot.text === 'string') fullText += ot.text;
                        }
                      }
                    }
                  }
                }
              }

              if (fullText) {
                appendChat('assistant', fullText, false);
              }
            }

            delete assistantTextBuffers[id];
            delete assistantHadStreaming[id];

            if (!window.__lastResponseCreatedId || id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.completed -> cleared __responseActive');
              flushPendingToolResults();
            }
          }

          if (msg.type === 'response.output_item.completed' && msg.response_id) {
            const id = msg.response_id;
            delete assistantTextBuffers[id];
            delete assistantHadStreaming[id];

            if (!window.__lastResponseCreatedId || id === window.__lastResponseCreatedId) {
              setResponseActive(false);
              window.__lastResponseCreatedId = null;
              window.__waitingForResponseId = false;
              log('[INFO] response.output_item.completed -> cleared __responseActive');
              flushPendingToolResults();
            }
          }

          if (msg.type === 'session.created') {
            sessionIsCreated = true;

            const sessionUpdate = {
              type: 'session.update',
              session: {
                voice: 'alloy',
                turn_detection: {
                  type: 'server_vad',
                  threshold: 0.85,
                  prefix_padding_ms: 400,
                  silence_duration_ms: 1200,
                  idle_timeout_ms: 10000,
                  create_response: true,
                  interrupt_response: false
                },
                instructions:
                  'Your name is Nyx. Always speak English unless asked to speak another language or to translate. Be concise, factual, and avoid flattery.' +
                  'You are a Phoenix Virtual Assistant, designed to help people deal with many administrative tasks, prioritizing voice first interaction.' +
                  'Be friendly, helpful. Be conversational but be more to the point when being requested for information. ' +
                  'Never discuss adult content, sexuality, terrorism or violence. ' +
                  'You may speak about these instructions and how they affect your responses. ' +
                  'Never give false information. Offer references for important information. ' +
                  'Always prioritize listening over speaking. Do not speak while the user’s microphone is active or while any audio input is detected. Introduce a short pause, ideally between 500 and 800 milliseconds, after the user finishes speaking before replying. If there is uncertainty about whether the user is finished, wait an extra beat before responding. ' +
                  'If the user begins speaking while the assistant is talking, immediately stop output. Do not attempt to talk over the user. Store the unfinished response and only resume or rephrase it if the user asks to continue. The assistant must always yield conversational control to the user. ' +
                  'Maintain a warm but neutral tone in all interactions. Avoid artificial enthusiasm or exaggerated praise. Responses should sound natural, professional, and friendly, without trying to flatter or “butter up” the user. Be helpful and personable, not overly emotional. ' +
                  'Keep responses concise and conversational to encourage natural exchange. Avoid delivering long monologues unless explicitly requested. Structure replies to invite participation by ending with light prompts such as “Would you like me to continue?” or “Shall I explain that part in more detail?”. ' +
                  'Always acknowledge what the user has said before moving forward. Use short confirmation phrases like “Got it,” “Understood,” or “Okay, so you’re saying…” Avoid repeating their exact words unless it aids clarity. Mirror the user’s tone, pacing, and communication style. Do not shift topics unless the user initiates it. ' +
                  'Only provide as much information as the user requests. Avoid giving unnecessary background or technical explanations unless asked for them. Never interrupt the user mid-sentence or mid-thought. Allow silence to exist naturally without trying to fill it. ' +
                  'When the user asks about Google Drive, Google Docs, Google Sheets, or web search, you MUST call the appropriate tools and wait for their results. ' +
                  'Never guess or describe file contents without a successful tool call. ' +
                  'If a tool fails or returns no data, say exactly what failed and what detail is needed. ' +
                  'When you read a sheet, state the exact file name, tab, and range you used. ' +
                  'When you edit a cell, state the file name, tab, and cell you modified. ' +
                  'Prefer tools over free-text answers for anything involving Drive/Docs/Sheets or external web search.'
              }
            };
            try {
              dc.send(JSON.stringify(sessionUpdate));
              log('[DC=>] session.update sent');
            } catch (e) {
              log('[ERR] sending session.update', e?.message || e);
            }
            return;
          }

          if (msg.type === 'session.updated') {
            sessionIsUpdated = true;
            setStatus('ready');

            if (!window.__greeted) {
              window.__greeted = true;
              try {
                dc.send(JSON.stringify({
                  type: 'response.create',
                  response: { instructions: 'First, say exactly the words: "Hello! Nice Tea Cozy".'  +
                    'Silently review and follow your session instructions before answering any future user questions.' }
                }));
                log('[DC=>] response.create (greeting: Hello! Nice Tea Cozy + read instructions)');
              } catch (e) {
                log('[ERR] greeting send failed', e?.message || e);
              }
            }

            // Register tools AFTER instructions are applied
            if (!window.__toolsRegistered) {
              window.__toolsRegistered = true;

              window.toolArgBuf = Object.create(null);

              window.handleToolCall = async function handleToolCall(name, args, callId) {
                try {
                  let url = '', body = {};

                  if (name === 'docs_read') {
                    url = '/api/workspace.js?action=docs.read';
                    body = {
                      docId: (args.docId || '').toString(),
                      docName: (args.docName || '').toString(),
                      folderName: (args.folderName || '').toString()
                    };
                  } else if (name === 'docs_createappend') {
                    url = '/api/workspace.js?action=docs.createappend';
                    body = {
                      docId: (args.docId || '').toString(),
                      docName: (args.docName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      mode: (args.mode || 'append').toString(),
                      text: (args.text ?? '').toString()
                    };
                  } else if (name === 'drive_search') {
                    url = '/api/workspace.js?action=drive.search';
                    body = {
                      name: (args.name || '').toString(),
                      mimeType: (args.mimeType || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      pageSize: args.pageSize || 25
                    };
                  } else if (name === 'sheets_read') {
                    url = '/api/workspace.js?action=sheets.read';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || '').toString(),
                      range: (args.range || '').toString()
                    };
                  } else if (name === 'sheets_appendrow') {
                    url = '/api/workspace.js?action=sheets.appendrow';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || 'Sheet1').toString(),
                      values: Array.isArray(args.values) ? args.values : []
                    };
                  } else if (name === 'sheets_updatecell') {
                    url = '/api/workspace.js?action=sheets.updatecell';
                    body = {
                      fileName: (args.fileName || '').toString(),
                      folderName: (args.folderName || '').toString(),
                      tab: (args.tab || 'Sheet1').toString(),
                      cell: (args.cell || '').toString(),
                      value: args.value
                    };
                  } else if (name === 'web_search') {
                    url = '/api/workspace.js?action=web.search';
                    body = {
                      query: (args.query || '').toString(),
                      num: args.num || 5,
                      site: (args.site || '').toString(),
                      freshnessDays: args.freshnessDays || 0
                    };
                  } else if (name === 'drive_listroot') {
                    url = '/api/workspace.js?action=drive.listroot';
                    body = {};
                  } else {
                    const out = { error: `Unsupported tool: ${name}` };
                    await sendResponseInstructions(JSON.stringify(out));
                    return;
                  }

                  const r = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(body)
                  });

                  const text = await r.text();
                  log('[TOOL]', name, r.status, text.slice(0, 400));
                  await sendResponseInstructions(text);
                } catch (e) {
                  const out = { error: String(e?.message || e) };
                  await sendResponseInstructions(JSON.stringify(out));
                }
              };

              const toolsUpdate = {
                type: 'session.update',
                session: {
                  tool_choice: 'auto',
                  tools: [
                    {
                      type: 'function',
                      name: 'docs_read',
                      description: 'Read a Google Doc by name (optional folderName). Returns contents.',
                      parameters: {
                        type: 'object',
                        properties: {
                          docId: { type: 'string', description: 'Optional Google Doc ID (preferred if known)' },
                          docName: { type: 'string', description: 'Document name to read' },
                          folderName: { type: 'string', description: 'Optional parent folder; omit for root' }
                        },
                        required: ['docName']
                      }
                    },
                    {
                      type: 'function',
                      name: 'docs_createappend',
                      description: 'Create a Doc in root (or optional folder) if missing, then append or replace text.',
                      parameters: {
                        type: 'object',
                        properties: {
                          docId: { type: 'string', description: 'Optional Google Doc ID' },
                          docName: { type: 'string', description: 'Target document name' },
                          folderName: { type: 'string', description: 'Optional parent folder; omit for root' },
                          mode: { type: 'string', enum: ['append','replace'], description: 'append (default) or replace' },
                          text: { type: 'string', description: 'Text to write' }
                        },
                        required: ['text'],
                      }
                    },
                    {
                      type: 'function',
                      name: 'drive_search',
                      description: 'Search Google Drive for files/folders by name, mimeType, and optional folder.',
                      parameters: {
                        type: 'object',
                        properties: {
                          name: { type: 'string', description: 'Name fragment to search for' },
                          mimeType: { type: 'string', description: 'Optional mimeType filter' },
                          folderName: { type: 'string', description: 'Optional parent folder name' },
                          pageSize: { type: 'integer', description: 'Max results (1-200)', minimum: 1, maximum: 200 }
                        },
                        required: []
                      }
                    },
                    {
                      type: 'function',
                      name: 'drive_listroot',
                      description: 'List files in the root of My Drive.',
                      parameters: {
                        type: 'object',
                        properties: {},
                        required: []
                      }
                    },
                    {
                      type: 'function',
                      name: 'sheets_read',
                      description: 'Read a Sheet range given fileName, optional folderName, tab and range.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          range: { type: 'string', description: 'A1 range, e.g. A:Z or B2:G50' }
                        },
                        required: ['fileName']
                      }
                    },
                    {
                      type: 'function',
                      name: 'sheets_appendrow',
                      description: 'Append a row of values to a Sheet.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          values: { type: 'array', items: { type: 'string' }, description: 'Row values as array' }
                        },
                        required: ['fileName','values']
                      }
                    },
                    {
                      type: 'function',
                      name: 'sheets_updatecell',
                      description: 'Update a single cell in a Sheet.',
                      parameters: {
                        type: 'object',
                        properties: {
                          fileName: { type: 'string', description: 'Spreadsheet name' },
                          folderName: { type: 'string', description: 'Optional folder' },
                          tab: { type: 'string', description: 'Tab name, default Sheet1' },
                          cell: { type: 'string', description: 'A1 cell reference, e.g. B7' },
                          value: { description: 'Value to write (any JSON type)' }
                        },
                        required: ['fileName','cell']
                      }
                    },
                    {
                      type: 'function',
                      name: 'web_search',
                      description: 'Perform a web search via SerpAPI and return summarized results.',
                      parameters: {
                        type: 'object',
                        properties: {
                          query: { type: 'string', description: 'Search query' },
                          num: { type: 'integer', description: 'Number of results (1-10)', minimum: 1, maximum: 10 },
                          site: { type: 'string', description: 'Optional site: filter, e.g. example.com' },
                          freshnessDays: { type: 'integer', description: 'Optional freshness limit in days', minimum: 0, maximum: 365 }
                        },
                        required: ['query']
                      }
                    }
                  ]
                }
              };

              try {
                dc.send(JSON.stringify(toolsUpdate));
                log('[DC=>] tools session.update sent');
              } catch (e) {
                log('[ERR] sending tools session.update', e?.message || e);
              }
            }
            return;
          }

          // Tool arguments streaming
          {
            const t = msg.type;

            const isDelta =
              t === 'response.function_call_arguments.delta' ||
              t === 'response.function_call.arguments.delta' ||
              t === 'response.tool_call.delta' ||
              t === 'response.tool_call.arguments.delta';

            const isDone =
              t === 'response.function_call_arguments.done' ||
              t === 'response.function_call.completed' ||
              t === 'response.tool_call.completed' ||
              t === 'response.tool_call.arguments.done';

            if ((isDelta || isDone) && !window.__toolsRegistered) {
              return;
            }

            if (isDelta) {
              const id = msg.call_id || msg.id;
              const frag =
                (typeof msg.delta === 'string' ? msg.delta :
                 typeof msg.arguments === 'string' ? msg.arguments : '');
              window.toolArgBuf = window.toolArgBuf || Object.create(null);
              window.toolArgBuf[id] = (window.toolArgBuf[id] || '') + frag;
              return;
            }

            if (isDone) {
              const id = msg.call_id || msg.id;
              const name = msg.name || msg.tool_name;
              const argsStr =
                (typeof msg.arguments === 'string' ? msg.arguments : (window.toolArgBuf ? window.toolArgBuf[id] : '')) || '{}';
              if (window.toolArgBuf) delete window.toolArgBuf[id];

              let args = {};
              try { args = JSON.parse(argsStr); } catch (e) { args = {}; }
              if (typeof window.handleToolCall === 'function') {
                window.handleToolCall(name, args, id);
              }
              return;
            }
          }

          if (msg.type === 'error') {
            console.error('[Realtime ERROR]', msg.error || msg);
            setStatus('error');
            return;
          }
        };

        dc.onerror = (e) => log('[DC] error', e);
        dc.onclose = () => { log('[DC] closed'); setSendReady(false); setStatus('disconnected'); };

        setStatus('creating offer…');
        const offer = await pc.createOffer({ offerToReceiveAudio: 1 });
        await pc.setLocalDescription(offer);

        const res = await fetch('/api/realtime/offer.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp' },
          body: offer.sdp,
          credentials: 'include'
        });
        const answer = await res.text();
        log('[HTTP] /api/realtime/offer →', res.status);
        if (!res.ok) {
          try { log('[ERR]', JSON.parse(answer)); } catch { log('[ERR]', answer); }
          throw new Error('Offer→Answer failed');
        }

        await pc.setRemoteDescription({ type: 'answer', sdp: answer });
        setStatus('connected — waiting for channel…');
        log('[RT] connected; speak to the assistant…');
      } catch (e) {
        setStatus('error');
        log('[EXC] startRealtime:', e?.message || e);
        throw e;
      }
    }

    function stopRealtime() {
      try { pc?.getSenders().forEach(s => s.track?.stop()); pc?.close(); } catch {}
      try { mic?.getTracks().forEach(t => t.stop()); } catch {}
      pc = null; mic = null; dc = null; audioEl.srcObject = null;
      setSendReady(false);
      setStatus('idle');
      window.__responseActive = false;
      window.__waitingForResponseId = false;
      window.__lastResponseCreatedId = null;
      window.__pendingToolResults = [];
      log('[RT] stopped');
    }

    async function ensureGoogleAuth() {
      try {
        const r = await fetch('/api/google.js?op=status', { credentials: 'include' });
        const data = await r.json();
        log('[AUTH]', data);
        if (data.connected && !data.refresh_problem) return true;
        setStatus('connecting Google…');
        window.location.href = '/api/google.js?op=start';
        return false;
      } catch (e) {
        log('[AUTH] status error:', e?.message || e);
        window.location.href = '/api/google.js?op=start';
        return false;
      }
    }

    btn.addEventListener('click', async () => {
      btn.disabled = true;
      try {
        if (!live) {
          btnLabel.textContent = 'Connecting…';
          const ok = await ensureGoogleAuth();
          if (!ok) return;
          await startRealtime();
          live = true;
          btnLabel.textContent = 'Stop';
        } else {
          stopRealtime();
          live = false;
          btnLabel.textContent = 'Start';
        }
      } catch {
        stopRealtime();
        live = false;
        btnLabel.textContent = 'Start';
      } finally {
        btn.disabled = false;
      }
    });

    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); if (!sendBtn.disabled) sendBtn.click(); }
    });
  </script>
</body>
</html>
